"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var QUnit = require("steal-qunit");

var StacheElement = require("./can-stache-element");

var value = require("can-value");

var browserSupports = require("../test/browser-supports");

var canReflect = require("can-reflect");

var fixture;
QUnit.module("can-stache-element - mixin-bindings", {
  beforeEach: function beforeEach() {
    fixture = document.querySelector("#qunit-fixture");
  }
});

if (browserSupports.customElements) {
  QUnit.test("basics work", function (assert) {
    var BasicBindingsElement =
    /*#__PURE__*/
    function (_StacheElement) {
      _inherits(BasicBindingsElement, _StacheElement);

      function BasicBindingsElement() {
        _classCallCheck(this, BasicBindingsElement);

        return _possibleConstructorReturn(this, _getPrototypeOf(BasicBindingsElement).apply(this, arguments));
      }

      _createClass(BasicBindingsElement, null, [{
        key: "view",
        get: function get() {
          return "<h1>{{message}}</h1>";
        }
      }, {
        key: "props",
        get: function get() {
          return {
            message: {
              type: String,
              default: "Hi"
            }
          };
        }
      }]);

      return BasicBindingsElement;
    }(StacheElement);

    customElements.define("basic-bindings", BasicBindingsElement);
    var basicBindingsElement = new BasicBindingsElement();
    var messageObservable = value.with("Hello");
    basicBindingsElement.bindings({
      message: messageObservable
    });
    assert.equal(basicBindingsElement.message, "Hi", "properties initialized later"); //-> The binding should really only happen once inserted ...
    // -> Folks could call `var el = new Element().bindings({}).initialize()`
    // INSERT ELEMENT

    fixture.appendChild(basicBindingsElement);
    assert.equal(basicBindingsElement.message, "Hello", "properties initialized");
    assert.equal(basicBindingsElement.innerHTML, "<h1>Hello</h1>", "template rendered"); // UPDATE observable

    messageObservable.value = "HOWDY";
    assert.equal(basicBindingsElement.message, "HOWDY", "element property value changed");
    assert.equal(basicBindingsElement.innerHTML, "<h1>HOWDY</h1>", "html updated"); // UPDATE element

    basicBindingsElement.message = "Hola!";
    assert.equal(messageObservable.value, "Hola!", "observable updated via two-way binding"); // REMOVE ELEMENT

    fixture.removeChild(basicBindingsElement); //basicBindingsElement[state].isInitialized //-> false

    /* Question 2: Should we blow away the innerHTML?
     *  + It won't be live anymore
     *  - It will be unnecessarily expensive to do this
     * */

    assert.equal(canReflect.isBound(messageObservable), false, "the observable is not bound");
    assert.equal(canReflect.isBound(basicBindingsElement), false, "the element is not bound"); // INSERT ELEMENT AGAIN

    messageObservable.value = "GOODBYE";
    fixture.appendChild(basicBindingsElement);
    assert.equal(basicBindingsElement.message, "GOODBYE", "properties initialized after re-insertion");
    assert.equal(basicBindingsElement.innerHTML, "<h1>GOODBYE</h1>", "template rendered");
  });
  QUnit.test("Everything is properly torn down", function (assert) {
    var done = assert.async();
    var oneId = 0,
        twoId = 0;

    var One =
    /*#__PURE__*/
    function (_StacheElement2) {
      _inherits(One, _StacheElement2);

      function One() {
        _classCallCheck(this, One);

        return _possibleConstructorReturn(this, _getPrototypeOf(One).apply(this, arguments));
      }

      _createClass(One, [{
        key: "setId",
        value: function setId(val) {
          oneId = val;
        }
      }], [{
        key: "view",
        get: function get() {
          return "\n\t\t\t\t\t{{this.setId(id)}}\n\t\t\t\t\t<p id=\"oneid\">{{id}}</p>\n\t\t\t\t";
        }
      }, {
        key: "props",
        get: function get() {
          return {
            id: Number
          };
        }
      }]);

      return One;
    }(StacheElement);

    customElements.define("o-ne", One);

    var Two =
    /*#__PURE__*/
    function (_StacheElement3) {
      _inherits(Two, _StacheElement3);

      function Two() {
        _classCallCheck(this, Two);

        return _possibleConstructorReturn(this, _getPrototypeOf(Two).apply(this, arguments));
      }

      _createClass(Two, [{
        key: "setId",
        value: function setId(val) {
          twoId = val;
        }
      }], [{
        key: "view",
        get: function get() {
          return "\n\t\t\t\t\t{{this.setId(id)}}\n\t\t\t\t\t<p id=\"twoid\">{{id}}</p>\n\t\t\t\t";
        }
      }, {
        key: "props",
        get: function get() {
          return {
            id: Number
          };
        }
      }]);

      return Two;
    }(StacheElement);

    customElements.define("t-wo", Two);

    var App =
    /*#__PURE__*/
    function (_StacheElement4) {
      _inherits(App, _StacheElement4);

      function App() {
        _classCallCheck(this, App);

        return _possibleConstructorReturn(this, _getPrototypeOf(App).apply(this, arguments));
      }

      _createClass(App, [{
        key: "increment",
        value: function increment() {
          this.id++;
        }
      }], [{
        key: "view",
        get: function get() {
          return "\n\t\t\t\t\t<p>\n\t\t\t\t\t\t{{#if(elementPromise.isResolved)}}\n\t\t\t\t\t\t\t{{{element}}}\n\t\t\t\t\t\t{{/if}}\n\t\t\t\t\t</p>\n\n\t\t\t\t\t<button on:click=\"increment()\">+1</button>\n\t\t\t\t";
        }
      }, {
        key: "props",
        get: function get() {
          return {
            id: 1,
            elementPromise: {
              get: function get() {
                var _this = this;

                return new Promise(function (resolve) {
                  var child = _this.id === 1 ? new One() : new Two();
                  child.bindings({
                    id: value.from(_this, "id")
                  });
                  child.connect();
                  resolve(child);
                });
              }
            },
            element: {
              async: function async(resolve) {
                this.elementPromise.then(resolve);
              }
            }
          };
        }
      }]);

      return App;
    }(StacheElement);

    customElements.define("a-pp", App);
    var app = new App();
    app.connect();
    app.on('element', function onFirst() {
      app.off('element', onFirst);
      app.on('element', function onSecond() {
        app.off('element', onSecond);
        assert.equal(oneId, 1, "Has its original id");
        assert.equal(twoId, 2, "Has its own id");
        done();
      });
      var oneEl = app.querySelector('o-ne');
      app.increment();
      assert.equal(oneEl.querySelector('#oneid').textContent, "1", "Has not changed");
    });
  });
  QUnit.test("All bindings are torn down", function (assert) {
    var BindingsTeardownElement =
    /*#__PURE__*/
    function (_StacheElement5) {
      _inherits(BindingsTeardownElement, _StacheElement5);

      function BindingsTeardownElement() {
        _classCallCheck(this, BindingsTeardownElement);

        return _possibleConstructorReturn(this, _getPrototypeOf(BindingsTeardownElement).apply(this, arguments));
      }

      _createClass(BindingsTeardownElement, null, [{
        key: "view",
        get: function get() {
          return "<h1>{{greeting}} {{object}}</h1>";
        }
      }, {
        key: "props",
        get: function get() {
          return {
            greeting: {
              type: String,
              default: "Hi"
            },
            object: {
              type: String,
              default: "person"
            }
          };
        }
      }]);

      return BindingsTeardownElement;
    }(StacheElement);

    customElements.define("bindings-teardown-element", BindingsTeardownElement);
    var teardownElement = new BindingsTeardownElement();
    var greetingObservable = value.with("Hello");
    var objectObservable = value.with("world");
    teardownElement.bindings({
      greeting: greetingObservable,
      object: objectObservable
    });
    teardownElement.connect();
    var h1 = teardownElement.firstElementChild;
    assert.equal(teardownElement.greeting, "Hello", "greetingObservable set up correctly");
    assert.equal(teardownElement.object, "world", "objectObservable set up correctly");
    assert.equal(h1.innerHTML, "Hello world", "view rendered");
    teardownElement.disconnect();
    greetingObservable.value = "Howdy";
    objectObservable.value = "Mars";
    assert.equal(teardownElement.greeting, "Hello", "greetingObservable torn down correctly");
    assert.equal(teardownElement.object, "world", "objectObservable torn down correctly");
    assert.equal(h1.innerHTML, "Hello world", "view not updated");
  });
  QUnit.test("Lifecycle methods return the element", function (assert) {
    var BindingsMethodsElement =
    /*#__PURE__*/
    function (_StacheElement6) {
      _inherits(BindingsMethodsElement, _StacheElement6);

      function BindingsMethodsElement() {
        _classCallCheck(this, BindingsMethodsElement);

        return _possibleConstructorReturn(this, _getPrototypeOf(BindingsMethodsElement).apply(this, arguments));
      }

      return BindingsMethodsElement;
    }(StacheElement);

    customElements.define("bindings-methods-element", BindingsMethodsElement);
    var obj = new BindingsMethodsElement().bindings().initialize().render().connect().disconnect();
    assert.ok(obj instanceof BindingsMethodsElement, "initialize, render, connect, disconnect");
  });
}