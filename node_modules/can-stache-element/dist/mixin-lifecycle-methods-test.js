"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var QUnit = require("steal-qunit");

var mixinLifecycleMethods = require("./mixin-lifecycle-methods");

var browserSupports = require("../test/browser-supports");

var inSetupSymbol = Symbol.for("can.initializing");
QUnit.module("can-stache-element - mixin-lifecycle-methods");
QUnit.test("connectedCallback calls hooks - initialize, render, connect", function (assert) {
  assert.expect(3);

  var Obj =
  /*#__PURE__*/
  function () {
    function Obj() {
      _classCallCheck(this, Obj);
    }

    _createClass(Obj, [{
      key: "initialize",
      value: function initialize() {
        assert.ok(true, "initialize called");
      }
    }, {
      key: "render",
      value: function render() {
        assert.ok(true, "render called");
      }
    }, {
      key: "connect",
      value: function connect() {
        assert.ok(true, "connect called");
      }
    }]);

    return Obj;
  }();

  var LifecycleObj = mixinLifecycleMethods(Obj);
  var obj = new LifecycleObj();
  obj.connectedCallback();
});
QUnit.test("disconnectedCallback calls disconnect, teardown returned by connected, and stopListening", function (assert) {
  assert.expect(3);
  var obj;

  var Obj =
  /*#__PURE__*/
  function () {
    function Obj() {
      _classCallCheck(this, Obj);
    }

    _createClass(Obj, [{
      key: "connected",
      value: function connected() {
        return function () {
          assert.ok(true, "teardown handler returned from `connect` is called");
        };
      }
    }, {
      key: "disconnect",
      value: function disconnect() {
        assert.ok(true, "disconnect called");
      }
    }, {
      key: "stopListening",
      value: function stopListening() {
        assert.ok(true, "stopListening called");
      }
    }]);

    return Obj;
  }();

  var LifecycleObj = mixinLifecycleMethods(Obj);
  obj = new LifecycleObj();
  obj.connectedCallback();
  obj.disconnectedCallback();
});

if (browserSupports.customElements) {
  QUnit.test("lifecycle works with document.createElement", function (assert) {
    assert.expect(4);
    var fixture = document.querySelector("#qunit-fixture");

    var Obj =
    /*#__PURE__*/
    function (_HTMLElement) {
      _inherits(Obj, _HTMLElement);

      function Obj() {
        _classCallCheck(this, Obj);

        return _possibleConstructorReturn(this, _getPrototypeOf(Obj).apply(this, arguments));
      }

      _createClass(Obj, [{
        key: "initialize",
        value: function initialize() {
          assert.ok(true, "initialize called");
        }
      }, {
        key: "render",
        value: function render() {
          assert.ok(true, "render called");
        }
      }, {
        key: "connect",
        value: function connect() {
          assert.ok(true, "connect called");
        }
      }, {
        key: "disconnect",
        value: function disconnect() {
          assert.ok(true, "disconnect called");
        }
      }]);

      return Obj;
    }(_wrapNativeSuper(HTMLElement));

    var LifecycleObj = mixinLifecycleMethods(Obj);
    customElements.define("created-el", LifecycleObj);
    var el = document.createElement("created-el");
    fixture.appendChild(el);
    fixture.removeChild(el);
  });
}

QUnit.test("events are not dispatched in initialize, are dispatched during render|connect", function (assert) {
  assert.expect(3);

  var Obj =
  /*#__PURE__*/
  function (_mixinLifecycleMethod) {
    _inherits(Obj, _mixinLifecycleMethod);

    function Obj() {
      _classCallCheck(this, Obj);

      return _possibleConstructorReturn(this, _getPrototypeOf(Obj).apply(this, arguments));
    }

    _createClass(Obj, [{
      key: "initialize",
      value: function initialize() {
        assert.equal(this[inSetupSymbol], true, "inSetupSymbol is true during initialize");

        _get(_getPrototypeOf(Obj.prototype), "initialize", this).call(this);
      }
    }, {
      key: "render",
      value: function render() {
        assert.equal(this[inSetupSymbol], false, "inSetupSymbol is false during render");

        _get(_getPrototypeOf(Obj.prototype), "render", this).call(this);
      }
    }, {
      key: "connect",
      value: function connect() {
        assert.equal(this[inSetupSymbol], false, "inSetupSymbol is false during connect");
      }
    }]);

    return Obj;
  }(mixinLifecycleMethods(Object));

  var obj = new Obj();
  obj.connectedCallback();
});
QUnit.test("events are not dispatched in initialize, are dispatched during render|connect when methods are called directly", function (assert) {
  assert.expect(3);

  var Obj =
  /*#__PURE__*/
  function (_mixinLifecycleMethod2) {
    _inherits(Obj, _mixinLifecycleMethod2);

    function Obj() {
      _classCallCheck(this, Obj);

      return _possibleConstructorReturn(this, _getPrototypeOf(Obj).apply(this, arguments));
    }

    _createClass(Obj, [{
      key: "initialize",
      value: function initialize() {
        assert.equal(this[inSetupSymbol], true, "inSetupSymbol is true during initialize");

        _get(_getPrototypeOf(Obj.prototype), "initialize", this).call(this);
      }
    }, {
      key: "render",
      value: function render() {
        assert.equal(this[inSetupSymbol], false, "inSetupSymbol is false during render");

        _get(_getPrototypeOf(Obj.prototype), "render", this).call(this);
      }
    }, {
      key: "connect",
      value: function connect() {
        assert.equal(this[inSetupSymbol], false, "inSetupSymbol is false during connect");
      }
    }]);

    return Obj;
  }(mixinLifecycleMethods(Object));

  var obj = new Obj();
  obj.initialize();
  obj.render();
  obj.connect();
});
QUnit.test("initialize, render, and connect are only called the first time connectedCallback is called", function (assert) {
  assert.expect(3);

  var Obj =
  /*#__PURE__*/
  function () {
    function Obj() {
      _classCallCheck(this, Obj);
    }

    _createClass(Obj, [{
      key: "initialize",
      value: function initialize() {
        assert.ok(true, "initialize");
      }
    }, {
      key: "render",
      value: function render() {
        assert.ok(true, "render");
      }
    }, {
      key: "connect",
      value: function connect() {
        assert.ok(true, "connect");
      }
    }]);

    return Obj;
  }();

  var LifecycleObj = mixinLifecycleMethods(Obj);
  var obj = new LifecycleObj();
  obj.connectedCallback();
  obj.connectedCallback();
});
QUnit.test("disconnect is only called the first time disconnectedCallback is called", function (assert) {
  assert.expect(1);

  var Obj =
  /*#__PURE__*/
  function () {
    function Obj() {
      _classCallCheck(this, Obj);
    }

    _createClass(Obj, [{
      key: "disconnect",
      value: function disconnect() {
        assert.ok(true, "connect");
      }
    }]);

    return Obj;
  }();

  var LifecycleObj = mixinLifecycleMethods(Obj);
  var obj = new LifecycleObj();
  obj.disconnectedCallback();
  obj.disconnectedCallback();
});
QUnit.test("render calls initialize if it was not called", function (assert) {
  assert.expect(2);

  var Obj =
  /*#__PURE__*/
  function (_mixinLifecycleMethod3) {
    _inherits(Obj, _mixinLifecycleMethod3);

    function Obj() {
      _classCallCheck(this, Obj);

      return _possibleConstructorReturn(this, _getPrototypeOf(Obj).apply(this, arguments));
    }

    _createClass(Obj, [{
      key: "initialize",
      value: function initialize() {
        _get(_getPrototypeOf(Obj.prototype), "initialize", this).call(this);

        assert.ok(true, "initialize");
      }
    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(Obj.prototype), "render", this).call(this);

        assert.ok(true, "render");
      }
    }]);

    return Obj;
  }(mixinLifecycleMethods(Object));

  var obj = new Obj();
  obj.render();
});
QUnit.test("constructor throws if passed arguments", function (assert) {
  var Obj =
  /*#__PURE__*/
  function (_mixinLifecycleMethod4) {
    _inherits(Obj, _mixinLifecycleMethod4);

    function Obj() {
      _classCallCheck(this, Obj);

      return _possibleConstructorReturn(this, _getPrototypeOf(Obj).apply(this, arguments));
    }

    return Obj;
  }(mixinLifecycleMethods(Object));

  try {
    new Obj({
      foo: "bar"
    });
  } catch (e) {
    assert.ok(true);
  }
});
QUnit.test("initial props should always be passed to initialize", function (assert) {
  assert.expect(4);
  var props = {
    foo: "bar",
    baz: "bap"
  };

  var Obj =
  /*#__PURE__*/
  function (_mixinLifecycleMethod5) {
    _inherits(Obj, _mixinLifecycleMethod5);

    function Obj() {
      _classCallCheck(this, Obj);

      return _possibleConstructorReturn(this, _getPrototypeOf(Obj).apply(this, arguments));
    }

    _createClass(Obj, [{
      key: "initialize",
      value: function initialize(initializeProps) {
        _get(_getPrototypeOf(Obj.prototype), "initialize", this).call(this);

        assert.equal(initializeProps, props, "Correct props passed to initialize");
      }
    }]);

    return Obj;
  }(mixinLifecycleMethods(Object));

  var initializeObj = new Obj();
  initializeObj.initialize(props);
  var renderObj = new Obj();
  renderObj.render(props);
  var connectObj = new Obj();
  connectObj.connect(props);
  var connectedCallbackObj = new Obj();
  connectedCallbackObj.connectedCallback(props);
});
QUnit.test("connect calls `connected` hook", function (assert) {
  assert.expect(1);

  var Obj =
  /*#__PURE__*/
  function (_mixinLifecycleMethod6) {
    _inherits(Obj, _mixinLifecycleMethod6);

    function Obj() {
      _classCallCheck(this, Obj);

      return _possibleConstructorReturn(this, _getPrototypeOf(Obj).apply(this, arguments));
    }

    _createClass(Obj, [{
      key: "connected",
      value: function connected() {
        assert.ok(true, "connected hook called");
      }
    }]);

    return Obj;
  }(mixinLifecycleMethods(Object));

  var obj = new Obj();
  obj.connect();
});
QUnit.test("disconnect calls `disconnected` hook", function (assert) {
  assert.expect(1);

  var Obj =
  /*#__PURE__*/
  function (_mixinLifecycleMethod7) {
    _inherits(Obj, _mixinLifecycleMethod7);

    function Obj() {
      _classCallCheck(this, Obj);

      return _possibleConstructorReturn(this, _getPrototypeOf(Obj).apply(this, arguments));
    }

    _createClass(Obj, [{
      key: "disconnected",
      value: function disconnected() {
        assert.ok(true, "disconnected hook called");
      }
    }]);

    return Obj;
  }(mixinLifecycleMethods(Object));

  var obj = new Obj();
  obj.disconnect();
});
QUnit.test("lifecycle methods return the obj", function (assert) {
  var Obj =
  /*#__PURE__*/
  function (_mixinLifecycleMethod8) {
    _inherits(Obj, _mixinLifecycleMethod8);

    function Obj() {
      _classCallCheck(this, Obj);

      return _possibleConstructorReturn(this, _getPrototypeOf(Obj).apply(this, arguments));
    }

    return Obj;
  }(mixinLifecycleMethods(Object));

  var obj = new Obj().connectedCallback().disconnectedCallback();
  assert.ok(obj instanceof Obj, "connectedCallback and disconnectedCallback");
  obj = new Obj().initialize().render().connect().disconnect();
  assert.ok(obj instanceof Obj, "initialize, render, connect, disconnect");
  obj = new Obj().initialize().initialize().render().render().connect().connect().disconnect().disconnect();
  assert.ok(obj instanceof Obj, "initialize, render, connect, disconnect called twice");
});