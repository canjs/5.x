Index: can-define-connected-singleton-test.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>'use strict';\n\nvar QUnit = require('steal-qunit');\nvar DefineMap = require('can-define/map/map');\nvar singleton = require('./can-define-connected-singleton');\n\nQUnit.module('can-define-connected-singleton');\n\nQUnit.test('Works as a simple class @decorator', function(assert){\n\tvar MyType = DefineMap.extend({});\n\tvar Decorated = singleton(MyType);\n\n\tassert.equal(MyType, Decorated);\n\tassert.ok(Decorated.hasOwnProperty('current'));\n\tassert.ok(Decorated.hasOwnProperty('currentPromise'));\n});\n\nQUnit.test('Works as a @decorator({ with_options })', function(assert){\n\tvar MyType = DefineMap.extend({});\n\tvar factory = singleton({});\n\tvar Decorated = factory(MyType);\n\n\tassert.equal(MyType, Decorated);\n\tassert.ok(Decorated.hasOwnProperty('current'));\n\tassert.ok(Decorated.hasOwnProperty('currentPromise'));\n});\n\nQUnit.test('Allows configurable property names', function(assert){\n\tvar MyType = DefineMap.extend({});\n\tvar Decorated = singleton({ currentPropertyName: 'foo', savingPropertyName: 'bar' })(MyType);\n\n\tassert.ok(Decorated.hasOwnProperty('bar'));\n\tassert.ok(Decorated.hasOwnProperty('foo'));\n\tassert.ok(Decorated.hasOwnProperty('fooPromise'));\n\tassert.notOk(Decorated.hasOwnProperty('current'));\n\tassert.notOk(Decorated.hasOwnProperty('currentPromise'));\n});\n\nQUnit.test('Calling \"current\" makes call to Type.get()', function(assert){\n\t// ensure that get() is only called once\n\tassert.expect(3);\n\tvar done = assert.async();\n\tvar MyType = DefineMap.extend({\n\t\tget: function() {\n\t\t\tassert.ok(true, 'get was called');\n\t\t\treturn Promise.resolve('the value!');\n\t\t}\n\t}, {});\n\n\tvar Decorated = singleton(MyType);\n\n\tassert.equal(Decorated.current, undefined, 'initially undefined');\n\tDecorated.currentPromise.then(function() {\n\t\tassert.equal(Decorated.current, 'the value!', 'has the expected value');\n\t\tdone();\n\t});\n});\n\nQUnit.test('Allows for configurable data method name', function(assert){\n\tassert.expect(3);\n\tvar done = assert.async();\n\tvar MyType = DefineMap.extend({\n\t\tdoFooBar: function() {\n\t\t\tassert.ok(true, 'doFooBar was called');\n\t\t\treturn Promise.resolve('the value!');\n\t\t}\n\t}, {});\n\n\tvar Decorated = singleton({ fetchMethodName: 'doFooBar' })(MyType);\n\n\tassert.equal(Decorated.current, undefined, 'initially undefined');\n\tDecorated.currentPromise.then(function() {\n\t\tassert.equal(Decorated.current, 'the value!', 'has the expected value');\n\t\tdone();\n\t});\n});\n\nQUnit.test('Saving a new instance updates the \"current\" and \"saving\" properties', function(assert){\n\tassert.expect(6);\n\tvar done = assert.async();\n\tvar MyType = singleton(\n\t\tDefineMap.extend({ \n\t\t\tget: function() {\n\t\t\t\tassert.ok(true, 'Get called but returns undefined. Should only happen once during this test.');\n\t\t\t\treturn Promise.resolve(undefined);\n\t\t\t},\n\t\t}, {\n\t\t\tsave: function() {\n\t\t\t\treturn new Promise((resolve) => {\n\t\t\t\t\tsetTimeout(() => resolve(this), 100);\n\t\t\t\t});\n\t\t\t}\n\t\t})\n\t);\n\n\tvar instance = new MyType();\n\tassert.notEqual(MyType.current, instance);\n\tvar promise = instance.save();\n\tassert.equal(MyType.saving, instance);\n\n\tpromise.then(() => {\n\t\tassert.equal(MyType.current, instance);\n\t\tassert.notEqual(MyType.saving, instance);\n\n\t\tMyType.currentPromise.then(function(value) {\n\t\t\tassert.equal(value, instance);\n\t\t\tdone();\n\t\t});\n\t});\n});\n\nQUnit.test('Allows for configurable save method name', function(assert){\n\tassert.expect(4);\n\tvar done = assert.async();\n\tvar MyType = singleton({ createMethodName: 'doFooBar' })(\n\t\tDefineMap.extend({\n\t\t\tget: function() {\n\t\t\t\tassert.ok(true, 'Get called but returns undefined. Should only happen once during this test.');\n\t\t\t\treturn Promise.resolve(undefined);\n\t\t\t},\n\t\t}, {\n\t\t\tdoFooBar: function() {\n\t\t\t\treturn Promise.resolve(this);\n\t\t\t}\n\t\t})\n\t);\n\n\tvar instance = new MyType();\n\tassert.notEqual(MyType.current, instance);\n\n\tinstance.doFooBar().then(() => {\n\t\tassert.equal(MyType.current, instance);\n\n\t\tMyType.currentPromise.then(function(value) {\n\t\t\tassert.equal(value, instance);\n\t\t\tdone();\n\t\t});\n\t});\n});\n\nQUnit.test('Destroying sets the \"current\" property to undefined, with rejected promise', function(assert){\n\tassert.expect(2);\n\tvar done = assert.async();\n\tvar MyType = singleton(\n\t\tDefineMap.extend({ \n\t\t\tget: function() {\n\t\t\t\treturn Promise.resolve();\n\t\t\t}\n\t\t}, {\n\t\t\tsave: function() {\n\t\t\t\treturn Promise.resolve(this);\n\t\t\t},\n\t\t\tdestroy: function() {\n\t\t\t\treturn Promise.resolve();\n\t\t\t}\n\t\t})\n\t);\n\n\tvar instance = new MyType();\n\t\n\tinstance.save().then(() => {\n\t\tinstance.destroy().then(() => {\n\t\t\tassert.equal(MyType.current, undefined);\n\n\t\t\tMyType.currentPromise.then(function() {\n\t\t\t\tassert.notOk(true, 'should not get here');\n\t\t\t\tdone();\n\t\t\t}).catch(function(value) {\n\t\t\t\tassert.propEqual(value, {});\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n});\n\nQUnit.test('Allows for configurable destroy method name', function(assert){\n\tassert.expect(2);\n\tvar done = assert.async();\n\tvar MyType = singleton({ destroyMethodName: 'doFooBar' })(\n\t\tDefineMap.extend({\n\t\t\tget: function() {\n\t\t\t\treturn Promise.resolve();\n\t\t\t}\n\t\t}, {\n\t\t\tsave: function() {\n\t\t\t\treturn Promise.resolve(this);\n\t\t\t},\n\t\t\tdoFooBar: function() {\n\t\t\t\treturn Promise.resolve();\n\t\t\t}\n\t\t})\n\t);\n\n\tvar instance = new MyType();\n\n\tinstance.save().then(() => {\n\t\tinstance.doFooBar().then(() => {\n\t\t\tassert.equal(MyType.current, undefined);\n\n\t\t\tMyType.currentPromise.then(function() {\n\t\t\t\tassert.notOk(true, 'should not get here');\n\t\t\t\tdone();\n\t\t\t}).catch(function(value) {\n\t\t\t\tassert.propEqual(value, {});\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n});\n\nQUnit.test('Setting .current manually results in expected state.', function(assert){\n\tassert.expect(4);\n\tvar done = assert.async();\n\tvar MyType = singleton(\n\t\tDefineMap.extend({\n\t\t\tget: function() {\n\t\t\t\tassert.ok(false, 'fetch method should never be run while setting .current manually.');\n\t\t\t\treturn Promise.resolve();\n\t\t\t}\n\t\t})\n\t);\n\n\tvar instance = new MyType();\n\tvar promises = [];\n\n\tMyType.current = instance;\n\tassert.equal(MyType.current, instance);\n\tpromises.push(MyType.currentPromise.then((ins) => assert.equal(ins, instance)));\n\n\tMyType.current = undefined;\n\tassert.equal(MyType.current, undefined);\n\tpromises.push(MyType.currentPromise.catch((msg) => assert.propEqual(msg, {})));\n\n\tPromise.all(promises).then(() => done());\n});\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- can-define-connected-singleton-test.js	(date 1560984266000)
+++ can-define-connected-singleton-test.js	(date 1561045105000)
@@ -139,8 +139,8 @@
 });
 
 QUnit.test('Destroying sets the "current" property to undefined, with rejected promise', function(assert){
-	assert.expect(2);
 	var done = assert.async();
+	assert.expect(2);
 	var MyType = singleton(
 		DefineMap.extend({ 
 			get: function() {
@@ -161,21 +161,15 @@
 	instance.save().then(() => {
 		instance.destroy().then(() => {
 			assert.equal(MyType.current, undefined);
-
-			MyType.currentPromise.then(function() {
-				assert.notOk(true, 'should not get here');
-				done();
-			}).catch(function(value) {
-				assert.propEqual(value, {});
-				done();
-			});
+			assert.rejects(MyType.currentPromise);
+			done();
 		});
 	});
 });
 
 QUnit.test('Allows for configurable destroy method name', function(assert){
-	assert.expect(2);
 	var done = assert.async();
+	assert.expect(2);
 	var MyType = singleton({ destroyMethodName: 'doFooBar' })(
 		DefineMap.extend({
 			get: function() {
@@ -196,14 +190,8 @@
 	instance.save().then(() => {
 		instance.doFooBar().then(() => {
 			assert.equal(MyType.current, undefined);
-
-			MyType.currentPromise.then(function() {
-				assert.notOk(true, 'should not get here');
-				done();
-			}).catch(function(value) {
-				assert.propEqual(value, {});
-				done();
-			});
+			assert.rejects(MyType.currentPromise);
+			done();
 		});
 	});
 });
@@ -229,7 +217,7 @@
 
 	MyType.current = undefined;
 	assert.equal(MyType.current, undefined);
-	promises.push(MyType.currentPromise.catch((msg) => assert.propEqual(msg, {})));
+	promises.push(assert.rejects(MyType.currentPromise));
 
 	Promise.all(promises).then(() => done());
 });
Index: can-define-connected-singleton.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>'use strict';\n\n\nvar reflect = require('can-reflect');\nvar DefineMap = require('can-define/map/map');\nvar ObservationRecorder = require('can-observation-recorder');\nvar zoneStorage = require('./util/zone-storage');\nvar helpers = require('./util/helpers');\n\nvar defaults = {\n\tstoragePrefix: 'can-define-connected-singleton',\n\tcurrentPropertyName: 'current',\n\tsavingPropertyName: 'saving',\n\tfetchMethodName: 'get',\n\tcreateMethodName: 'save',\n\tdestroyMethodName: 'destroy',\n};\n\nfunction isDefineMapConstructor(Obj) {\n\treturn Obj && (Obj.prototype instanceof DefineMap);\n}\n\n// wrap the createMethod so it updates .current, .currentPromise & .saving during the course of a singleton model being persisted\nfunction wrapCreateMethod(Ctor, options) {\n\tvar baseCreate = Ctor.prototype[options.createMethodName];\n\n\tCtor.prototype[options.createMethodName] = function wrappedCreate() {\n\t\tvar ret = baseCreate.apply(this, arguments);\n\n\t\t// set Ctor.saving & Ctor.currentPromise\n\t\tzoneStorage.setItem(options.storageKeys.savingProperty, this);\n\t\tCtor.dispatch(options.savingPropertyName, [this]);\n\t\tzoneStorage.setItem(options.storageKeys.currentPropertyPromise, ret);\n\t\tCtor.dispatch(options.currentPropertyPromiseName, [ret]);\n\n\t\tret.then(\n\t\t\t(instance) => {\n\t\t\t\t// clear Ctor.saving, set Ctor.current\n\t\t\t\tzoneStorage.setItem(options.storageKeys.savingProperty, undefined);\n\t\t\t\tCtor.dispatch(options.savingPropertyName, [undefined]);\n\t\t\t\tzoneStorage.setItem(options.storageKeys.currentProperty, instance);\n\t\t\t\tCtor.dispatch(options.currentPropertyName, [instance]);\n\t\t\t},\n\t\t\t() => {\n\t\t\t\t// clear saving\n\t\t\t\tzoneStorage.setItem(options.storageKeys.savingProperty, undefined);\n\t\t\t\tCtor.dispatch(options.savingPropertyName, [undefined]);\n\t\t\t}\n\t\t);\n\n\t\treturn ret;\n\t};\n}\n\n// wrap the destroyMethod so it updates .current & .currentPromise during the course of a singleton model being removed from persistence\nfunction wrapDestroyMethod(Ctor, options) {\n\tvar baseDestroy = Ctor.prototype[options.destroyMethodName];\n\n\tCtor.prototype[options.destroyMethodName] = function wrappedDestroy() {\n\t\tvar ret = baseDestroy.apply(this, arguments);\n\n\t\tret.then(() => {\n\t\t\tvar promise = Promise.reject({});\n\n\t\t\t// clear current, reject currentPromise w/ reason string if successful\n\t\t\tzoneStorage.setItem(options.storageKeys.currentProperty, undefined);\n\t\t\tCtor.dispatch(options.currentPropertyName, [undefined]);\n\t\t\tzoneStorage.setItem(options.storageKeys.currentPropertyPromise, promise);\n\t\t\tCtor.dispatch(options.currentPropertyPromiseName, [promise]);\n\t\t});\n\n\t\treturn ret;\n\t};\n}\n\nfunction checkForExistingKeys(options) {\n\tif (zoneStorage.getItem(options.storageKeys.currentProperty) ||\n\t\tzoneStorage.getItem(options.storageKeys.currentPropertyPromise) ||\n\t\tzoneStorage.getItem(options.storageKeys.savingProperty)) {\n\t\tconsole.warn('can-define-connected-singleton: Removing existing values from zone storage. You are likely configuring a singleton twice.');\n\t\tzoneStorage.removeItem(options.storageKeys.currentProperty);\n\t\tzoneStorage.removeItem(options.storageKeys.currentPropertyPromise);\n\t\tzoneStorage.removeItem(options.storageKeys.savingProperty);\n\t}\n}\n\n// get stored current & promise values, initializing them if they're not yet set\nfunction getCurrentAndPromise(Ctor, options) {\n\tvar current = zoneStorage.getItem(options.storageKeys.currentProperty);\n\tvar promise = zoneStorage.getItem(options.storageKeys.currentPropertyPromise);\n\n\tif (promise == null) {\n\t\tpromise = Ctor[options.fetchMethodName]();\n\t\tzoneStorage.setItem(options.storageKeys.currentPropertyPromise, promise);\n\t\tCtor.dispatch(options.currentPropertyPromiseName, [promise]);\n\n\t\tpromise.then(function (value) {\n\t\t\tzoneStorage.setItem(options.storageKeys.currentProperty, value);\n\t\t\tCtor.dispatch(options.currentPropertyName, [value]);\n\t\t})\n\t\t.catch(function () {\n\t\t\tzoneStorage.setItem(options.storageKeys.currentProperty, null);\n\t\t\tCtor.dispatch(options.currentPropertyName, [null]);\n\t\t});\n\t}\n\n\treturn {\n\t\tcurrent: current,\n\t\tpromise: promise\n\t};\n}\n\n\nfunction makeSingleton(Ctor, input_options){\n\tvar helpURL = 'https://canjs.com/doc/can-define-connected-singleton';\n\n\tif(!isDefineMapConstructor(Ctor)) {\n\t\tthrow new Error('The singleton decorator/mixin can only be used for DefineMaps: ' + helpURL);\n\t}\n\n\tvar savingPropertyName = input_options.savingPropertyName;\n\tvar currentPropertyName = input_options.currentPropertyName;\n\tvar currentPropertyPromiseName = currentPropertyName + 'Promise';\n\tvar currentPropertyKey = input_options.storagePrefix + '-' + Ctor.name + '-' + currentPropertyName;\n\tvar storageKeys = {\n\t\tsavingProperty: input_options.storagePrefix + '-' + Ctor.name + '-' + savingPropertyName,\n\t\tcurrentProperty: currentPropertyKey,\n\t\tcurrentPropertyPromise: currentPropertyKey + '-promise'\n\t};\n\tvar options = Object.assign({}, input_options, {\n\t\tcurrentPropertyPromiseName, storageKeys\n\t});\n\n\tcheckForExistingKeys(options);\n\n\tObject.defineProperty(Ctor, options.currentPropertyPromiseName, {\n\t\tget: function () {\n\t\t\tObservationRecorder.add(Ctor, options.currentPropertyPromiseName);\n\t\t\treturn getCurrentAndPromise(Ctor, options).promise;\n\t\t}\n\t});\n\n\tObject.defineProperty(Ctor, options.currentPropertyName, {\n\t\tget: function () {\n\t\t\tObservationRecorder.add(Ctor, options.currentPropertyName);\n\t\t\treturn getCurrentAndPromise(Ctor, options).current;\n\t\t},\n\t\t// The \"current\" property is not typically set via this setter, typically it will be set by the destroyMethod & createMethod wrappers, and getCurrentAndPromise. This setter is used when a user of this module wishes to force a state.\n\t\tset: function(instance) {\n\t\t\tif (!(instance instanceof Ctor) && instance !== undefined) {\n\t\t\t\tthrow new TypeError('Attempted to set singleton to an unexpected type. Expected an instance of the constructor \"' + reflect.getName(Ctor) + '\"');\n\t\t\t}\n\n\t\t\tlet promise = instance ?\n\t\t\t\tPromise.resolve(instance) :\n\t\t\t\tPromise.reject({});\n\n\t\t\tzoneStorage.setItem(options.storageKeys.currentProperty, instance);\n\t\t\tCtor.dispatch(options.currentPropertyName, [instance]);\n\t\t\tzoneStorage.setItem(options.storageKeys.currentPropertyPromise, promise);\n\t\t\tCtor.dispatch(options.currentPropertyPromiseName, [promise]);\n\t\t}\n\t});\n\n\tObject.defineProperty(Ctor, options.savingPropertyName, {\n\t\tget: function () {\n\t\t\tObservationRecorder.add(Ctor, options.savingPropertyName);\n\t\t\treturn zoneStorage.getItem(options.storageKeys.savingProperty);\n\t\t}\n\t});\n\n\twrapCreateMethod(Ctor, options);\n\twrapDestroyMethod(Ctor, options);\n\n\treturn Ctor;\n}\n\nfunction singleton(Obj) {\n\tvar opts = helpers.assign({}, defaults);\n\n\t// @singleton\n\tif(isDefineMapConstructor(Obj)) {\n\t\treturn makeSingleton(Obj, opts);\n\t}\n\n\t// @singleton(options)\n\treturn function(Ctor) {\n\t\treturn makeSingleton(Ctor, helpers.assign(opts, Obj));\n\t};\n}\n\nmodule.exports = singleton;\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- can-define-connected-singleton.js	(date 1560984266000)
+++ can-define-connected-singleton.js	(date 1561046091000)
@@ -59,17 +59,25 @@
 	Ctor.prototype[options.destroyMethodName] = function wrappedDestroy() {
 		var ret = baseDestroy.apply(this, arguments);
 
-		ret.then(() => {
-			var promise = Promise.reject({});
-
-			// clear current, reject currentPromise w/ reason string if successful
+		// return modified promise to ensure that storedPromise check runs before consumer of returned promise
+		return ret.then((value) => {
+			// clear current, reject currentPromise
 			zoneStorage.setItem(options.storageKeys.currentProperty, undefined);
 			Ctor.dispatch(options.currentPropertyName, [undefined]);
-			zoneStorage.setItem(options.storageKeys.currentPropertyPromise, promise);
-			Ctor.dispatch(options.currentPropertyPromiseName, [promise]);
-		});
+
+			// avoid setting promise a second time if can/session behavior callback handler has already set it to a rejected promise
+			const storedPromise = zoneStorage.getItem(options.storageKeys.currentPropertyPromise);
+			storedPromise.then(
+				() => {
+					var promise = Promise.reject(undefined);
+					zoneStorage.setItem(options.storageKeys.currentPropertyPromise, promise);
+					Ctor.dispatch(options.currentPropertyPromiseName, [promise]);
+				},
+				() => {} // promise is already rejected by can/session destroyedInstance callback
+			);
 
-		return ret;
+			return value;
+		});
 	};
 }
 
@@ -153,7 +161,7 @@
 
 			let promise = instance ?
 				Promise.resolve(instance) :
-				Promise.reject({});
+				Promise.reject(undefined);
 
 			zoneStorage.setItem(options.storageKeys.currentProperty, instance);
 			Ctor.dispatch(options.currentPropertyName, [instance]);
