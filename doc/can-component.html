<!DOCTYPE html>
<!--####################################################################
	THIS IS A GENERATED FILE — ANY CHANGES MADE WILL BE OVERWRITTEN

	INSTEAD CHANGE:
	source: node_modules/can-component/docs/component.md
	@module can-component
######################################################################## -->
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>can-component | Views | API Docs | CanJS</title>
	<meta name="description" content="Create a custom element that can be used to manage widgets or application logic.">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
	<meta property="og:image" content="https://www.bitovi.com/hubfs/open-source/os-canjs.png">
	<meta property="og:description" content="Create a custom element that can be used to manage widgets or application logic.">
	<meta property="og:title" content="can-component | Views | API Docs | CanJS">
	<script type="application/ld+json">
		{
			"@context": "http://www.schema.org",
			"@type": "SoftwareSourceCode",
			"applicationCategory": "DeveloperApplication",
			"brand": "Bitovi",
			"category": "JavaScript Frameworks",
			"codeRepository": "git://github.com/canjs/can-component.git",
			"description": "Create a custom element that can be used to manage widgets or application logic.",
			"image": "https://www.bitovi.com/hubfs/open-source/os-canjs.png",
			"license": "https://github.com/canjs/canjs/blob/master/license.md",
			"logo": "https://www.bitovi.com/hubfs/open-source/os-canjs.png",
			"name": "can-component | Views | API Docs | CanJS",
			"programmingLanguage": "JavaScript",
			"softwareVersion" : "4.6.2"
		}
	</script>
	
		<link rel="stylesheet" type="text/css" href="./static/bundles/bit-docs-site/static.css">
		<link rel="shortcut icon" sizes="16x16 24x24 32x32 48x48 64x64" href="/docs/images/canjs_favicon.ico">
		<link rel="apple-touch-icon" sizes="57x57" href="../docs/images/canjs_favicon_57x57.png">
		<link rel="apple-touch-icon-precomposed" sizes="57x57" href="../docs/images/canjs_favicon_57x57.png">
		<link rel="apple-touch-icon" sizes="72x72" href="../docs/images/canjs_favicon_72x72.png">
		<link rel="apple-touch-icon" sizes="114x114" href="../docs/images/canjs_favicon_114x114.png">
		<link rel="apple-touch-icon" sizes="120x120" href="../docs/images/canjs_favicon_128x128.png">
		<link rel="apple-touch-icon" sizes="144x144" href="../docs/images/canjs_favicon_144x144.png">
		<link rel="apple-touch-icon" sizes="152x152" href="../docs/images/canjs_favicon_152x152.png">
		<meta content="yes" name="apple-mobile-web-app-capable">
	  	<meta name="apple-mobile-web-app-status-bar-style" content="white-translucent">
	
	
		<script>
			(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
				(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
				m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

			ga('create', 'UA-2302003-11', 'auto');
			ga('send', 'pageview');
		</script>
	
</head>
	<body>
		<input type="checkbox" id="nav-trigger" class="nav-trigger"/>
	  	<div data-current-page="can-component" id="everything">
  <div class="header">
    
	<label for="nav-trigger">Menu</label>
	<div class="brand">
		<div class="logo">
			<a href="../index.html" alt="CanJS"></a>
			<div class="dropdown project-dropdown">
				<a href="https://donejs.com/">DoneJS</a>
				<a href="https://stealjs.com/">StealJS</a>
				<a href="https://jquerypp.com/">jQuery++</a>
				<a href="https://funcunit.com/">FuncUnit</a>
				<a href="https://documentjs.com/">DocumentJS</a>
			</div>
		</div>
		<div class="version">
			<div class="version-number">
				5.33.3
			</div>
			<div class="dropdown version-dropdown">
				
					<a href="https://canjs.com">6.0.0</a>
				
					<a href="https://v4.canjs.com">4.3.0</a>
				
					<a href="https://v3.canjs.com">3.14.1</a>
				
					<a href="https://v2.canjs.com">2.3.35</a>
				
			</div>
		</div>
	</div>


	
	<ul class="top-right-links">
		
			
				
					<li class="">
						<a class="page"
							href="about.html"
							title="Learn about CanJS’s mission, technical highlights, who uses CanJS, and our future roadmap.">
							About
						</a>
					</li>
				
			
		
			
				
					<li class="">
						<a class="page"
							href="guides.html"
							title="Welcome to CanJS! These guides are here to help you master CanJS development, get involved with the CanJS community, and contribute back to CanJS.">
							Guides
						</a>
					</li>
				
			
		
			
				
					<li class="current">
						<a class="page"
							href="api.html"
							title="Welcome to the CanJS API documentation! This page is a CHEAT-SHEET for the most common APIs within CanJS. Read the technology-overview page for background on the following APIs.">
							API Docs
						</a>
					</li>
				
			
		
			
				
					<li class="">
						<a class="page"
							href="community.html"
							title="Get involved with one of the most inviting communities on the internet!">
							Community
						</a>
					</li>
				
			
		
			
				
					<li class="">
						<a class="page"
							href="guides/contribute.html"
							title="Learn how to contribute to CanJS!">
							Contributing
						</a>
					</li>
				
			
		
	</ul>



<div class="search-section">
	<div class="search-bar">
	<div class="search-wrap" style="display:none;">
		<span class="search-icon"></span>
		<input
			type="text"
			size="6"
			class="search"
			placeholder="Search"
			autocomplete="off"
			autocorrect="off"
			autocapitalize="none"
			spellcheck="false"/>
			<span class="search-icon-cancel"></span>
	</div>
</div>

	<div class="search-bar-container">
	</div>
	<div class="search-results-container">
	<div class="search-results-wrap"></div>
</div>

</div>
<ul class="top-right-bitovi">
	<li class="dropdown">
		<a href="https://www.bitovi.com" class="bitovi by-bitovi">Bitovi</a>
		<ul class="dropdown-menu">
			<li><a href="https://www.bitovi.com/">Bitovi.com</a></li>
			<li><a href="https://www.bitovi.com/blog">Blog</a></li>
			<li><a href="https://www.bitovi.com/design">Design</a></li>
			<li><a href="https://www.bitovi.com/development">Development</a></li>
			<li><a href="https://www.bitovi.com/training">Training</a></li>
			<li><a href="https://www.bitovi.com/open-source">Open Source</a></li>
			<li><a href="https://www.bitovi.com/about">About</a></li>
			<li><a href="https://www.bitovi.com/contact">Contact Us</a></li>
		</ul>
	</li>
</ul>

  </div>
  <div id="left" class="column">

      <div class="nav-menu">
        
            
	<ul>
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="about.html"
							title="Learn about CanJS’s mission, technical highlights, who uses CanJS, and our future roadmap.">
							About
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="guides.html"
							title="Welcome to CanJS! These guides are here to help you master CanJS development, get involved with the CanJS community, and contribute back to CanJS.">
							Guides
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						parent
           						expanded">
						<a class="page"
							href="api.html"
							title="Welcome to the CanJS API documentation! This page is a CHEAT-SHEET for the most common APIs within CanJS. Read the technology-overview page for background on the following APIs.">
							API Docs
						</a>
						
	<ul>
		
			
				
					<li>
						<span>Observables</span>
						
	<ul>
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-bind.html"
							title="Updates one observable value with the value of another observable.">
							can-bind
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-compute.html"
							title="Create an observable value.">
							can-compute
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-debug.html"
							title="Useful debugging utilities.">
							can-debug
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-define.html"
							title="Defines observable properties and their behavior on a prototype object. This function is not commonly used directly. map and list are more commonly used. Types and behaviors shared by both map and list are documented here.">
							can-define
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-define/list/list.html"
							title="Create observable lists.">
							can-define/list/list
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-define/map/map.html"
							title="Create observable objects.">
							can-define/map/map
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-define-backup.html"
							title="">
							can-define-backup
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-define-stream.html"
							title="Add useful stream conversion methods to a supplied map or list constructor using a stream interface such as can-stream-kefir.">
							can-define-stream
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-define-stream-kefir.html"
							title="Export a function that takes a map or list constructor and uses can-stream-kefir to create streamable properties.">
							can-define-stream-kefir
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-event-queue.html"
							title="Mixin observable behavior to your types.">
							can-event-queue
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-kefir.html"
							title="Integrate KefirJS streams directly within can-stache and other parts of CanJS.">
							can-kefir
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-list.html"
							title="">
							can-list
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-map.html"
							title="Create observable objects.">
							can-map
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-map-compat.html"
							title="can-map-compat">
							can-map-compat
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-map-define.html"
							title="Defines the type, initial value, get, set, remove, and serialize behavior for attributes of a Map.">
							can-map-define
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-observable-array.html"
							title="Create observable arrays with defined properties.">
							can-observable-array
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-observable-object.html"
							title="Create observable objects used to manage state in explicitly defined ways.">
							can-observable-object
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-observation.html"
							title="Create observable values that derive their value from other observable values.">
							can-observation
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-observation-recorder.html"
							title="Specify how to listen to changes in a value being read and record those specifications between two points in time. Record observables being read and indicate how to listen to changes in a value being read.">
							can-observation-recorder
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-observe.html"
							title="Create observable objects, arrays, and functions that work like plain JavaScript objects, arrays, and functions.">
							can-observe
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-simple-map.html"
							title="A performant live-bound map.">
							can-simple-map
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-simple-observable.html"
							title="Create an observable value.">
							can-simple-observable
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-stream.html"
							title="Create useful stream methods from a minimal stream wrapper implementation.">
							can-stream
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-stream-kefir.html"
							title="Convert observable values into streams. Kefir is used to provide the stream functionality.">
							can-stream-kefir
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-value.html"
							title="Get an observable that’s bound to a specific property on another object.">
							can-value
						</a>
						

					</li>
				
			
		
	</ul>


					</li>
				
			
		
			
				
					<li>
						<span>Views</span>
						
	<ul>
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-attribute-observable.html"
							title="Create an observable value from an element&#x27;s property or attribute.">
							can-attribute-observable
						</a>
						

					</li>
				
			
		
			
				
					<li class="current
           						parent
           						expanded">
						<a class="module"
							href="can-component.html"
							title="Create a custom element that can be used to manage widgets or application logic.">
							can-component
						</a>
						
	<ul>
		
			
				
					<li>
						<span>define</span>
						
	<ul>
		
			
				
					<li class="
           						
           						">
						<a class="function"
							href="can-component.extend.html"
							title="Define the behavior of a custom element.">
							extend
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="property"
							href="can-component.prototype.tag.html"
							title="Specifies the HTML tag (or node-name) the can-component will be created on.">
							tag
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="property"
							href="can-component.prototype.view.html"
							title="Provides a view to render directly within the component’s element. The view is rendered with the component’s can-component::ViewModel instance.">
							view
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="property"
							href="can-component.prototype.ViewModel.html"
							title="Defines a class used to provide values and methods to the component’s view. The class is initialized with values specified by the component element’s data bindings.">
							ViewModel
						</a>
						

					</li>
				
			
		
	</ul>


					</li>
				
			
		
			
				
					<li>
						<span>create</span>
						
	<ul>
		
			
				
					<li class="
           						
           						">
						<a class="typedef"
							href="can-component/component-element.html"
							title="Create a component using HTML and can-stache-bindings.">
							&lt;tag bindings...&gt;
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="function"
							href="can-component.new.html"
							title="Programmatically instantiate a component">
							new Component
						</a>
						

					</li>
				
			
		
	</ul>


					</li>
				
			
		
			
				
					<li>
						<span>elements</span>
						
	<ul>
		
			
				
					<li class="
           						
           						">
						<a class="typedef"
							href="can-component/can-slot.html"
							title="Position the content of &lt;can-template&gt; elements.">
							&lt;can-slot&gt;
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="typedef"
							href="can-component/can-template.html"
							title="Pass templates declaratively to components.">
							&lt;can-template&gt;
						</a>
						

					</li>
				
			
		
	</ul>


					</li>
				
			
		
			
				
					<li>
						<span>lifecycle hooks</span>
						
	<ul>
		
			
				
					<li class="
           						
           						">
						<a class="typedef"
							href="can-component/connectedCallback.html"
							title="A lifecycle hook called after the component&#x27;s element is inserted into the document.">
							connectedCallback
						</a>
						

					</li>
				
			
		
	</ul>


					</li>
				
			
		
			
				
					<li>
						<span>deprecated</span>
						
	<ul>
		
			
				
					<li class="
           						
           						">
						<a class="typedef"
							href="can-component/beforeremove.html"
							title="An event called only on component’s elements before they are removed from the document if live binding is performing the removal. It can be listened to within a component’s can-component.prototype.events object or on a component element with can-stache-bindings.event bindings.  This is an additional special event only on component elements. Check out events for other mutation events.">
							beforeremove
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="typedef"
							href="can-component/content.html"
							title="Positions the LIGHT_DOM within a component’s can-component.prototype.view.">
							&lt;content&gt;
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="property"
							href="can-component.prototype.events.html"
							title="Listen to events on elements and observables.">
							events
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="property"
							href="can-component.prototype.helpers.html"
							title="Helper functions used with the component’s view.">
							helpers
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="property"
							href="can-component.prototype.leakScope.html"
							title="Allow reading the outer scope values from a component’s view and a component’s viewModel values in the user content.">
							leakScope
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="function"
							href="can-component.prototype.view-model.html"
							title="Return the view model instance or type with which the component’s can-component.prototype.view is rendered.  This is used when more fine grained control is needed over can-component::ViewModel.">
							viewModel
						</a>
						

					</li>
				
			
		
	</ul>


					</li>
				
			
		
	</ul>


					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-stache.html"
							title="Live binding templates.">
							can-stache
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-stache-bindings.html"
							title="Listen to events and create one-way and two-way bindings.">
							can-stache-bindings
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-stache-converters.html"
							title="Provides a set of converters useful for two-way binding with form elements such as &lt;input&gt; and &lt;select&gt;.">
							can-stache-converters
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-stache-element.html"
							title="Create a custom element with ObservableObject-like properties and stache views.">
							can-stache-element
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-stache-route-helpers.html"
							title="Adds routeUrl and routeCurrent helpers to stache.">
							can-stache-route-helpers
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-view-autorender.html"
							title="A module that automatically renders script and other elements with the can-autorender attribute. This function is useful to know when the templates have finished rendering.">
							can-view-autorender
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-view-callbacks.html"
							title="Registered callbacks for behaviors">
							can-view-callbacks
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-view-import.html"
							title="">
							can-view-import
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-view-live.html"
							title="Setup live-binding between the DOM and a compute manually.">
							can-view-live
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-view-model.html"
							title="Gets the ViewModel of an element.">
							can-view-model
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-view-nodelist.html"
							title="Adds nesting of text nodes">
							can-view-nodelist
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-view-parser.html"
							title="Parse HTML and mustache tokens.">
							can-view-parser
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-view-scope.html"
							title="Create a lookup node for keys.">
							can-view-scope
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-view-target.html"
							title="">
							can-view-target
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="steal-stache.html"
							title="A StealJS extension that allows stache templates as dependencies.">
							steal-stache
						</a>
						

					</li>
				
			
		
	</ul>


					</li>
				
			
		
			
				
					<li>
						<span>Data Modeling</span>
						
	<ul>
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-connect.html"
							title="can-connect provides persisted data middleware. Assemble powerful model layers from fully modularized behaviors (i.e. plugins).">
							can-connect
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-connect-feathers.html"
							title="Integrate can-connect with the FeathersJS Client">
							can-connect-feathers
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-connect-ndjson.html"
							title="Get a list of data from an NDJSON service endpoint.">
							can-connect-ndjson
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-connect-tag.html"
							title="Create custom elements that can be used to retrieve model instances.">
							can-connect-tag
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-fixture.html"
							title="Intercept AJAX requests and simulate the response.">
							can-fixture
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-fixture-socket.html"
							title="Simulate socket.io services.">
							can-fixture-socket
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-local-store.html"
							title="Create, update, delete and query data saved in localStorage.">
							can-local-store
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-memory-store.html"
							title="Create, update, delete and query data saved in memory.">
							can-memory-store
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-ndjson-stream.html"
							title="Parses an NDJSON stream into a stream of JavaScript objects.">
							can-ndjson-stream
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-query-logic.html"
							title="Perform data queries and compare queries against each other. Provides logic useful for data caching and real-time behavior.">
							can-query-logic
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-realtime-rest-model.html"
							title="Connect a type to a restful data source and automatically manage lists.">
							can-realtime-rest-model
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-rest-model.html"
							title="Connect a type to a restful service layer.">
							can-rest-model
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-set-legacy.html"
							title="can-set-legacy supports a legacy can-set API that creates a can-query-logic instance.">
							can-set-legacy
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-super-model.html"
							title="Connect a type to a restful data source, automatically manage lists, combine requests, and use a fall-through localstorage cache.">
							can-super-model
						</a>
						

					</li>
				
			
		
	</ul>


					</li>
				
			
		
			
				
					<li>
						<span>Routing</span>
						
	<ul>
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-deparam.html"
							title="Deserialize a query string into an array or object.">
							can-deparam
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-param.html"
							title="Serialize an object or array into a query string.">
							can-param
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-route.html"
							title="Manage browser history and client state by synchronizing the window.location.hash with an observable. See the Routing for in depth examples.">
							can-route
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-route-hash.html"
							title="An observable that is cross bound to the window.location.hash.">
							can-route-hash
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-route-mock.html"
							title="Simulate routing without having to change the URL.">
							can-route-mock
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-route-pushstate.html"
							title="An observable that can be used as can-route&#x27;s can-route.urlData.">
							can-route-pushstate
						</a>
						

					</li>
				
			
		
	</ul>


					</li>
				
			
		
			
				
					<li>
						<span>JS Utilities</span>
						
	<ul>
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-assign.html"
							title="A simplified version of Object.assign, which only accepts a single source argument.">
							can-assign
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-define-lazy-value.html"
							title="can-define-lazy-value">
							can-define-lazy-value
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-diff.html"
							title="Utilities for comparing and applying differences between data structures.">
							can-diff
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-globals.html"
							title="An environment agnostic container for global variables. Useful for testing and server-side rendering (SSR), typically used internally by CanJS.">
							can-globals
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-join-uris.html"
							title="Join together a URI path to a base.">
							can-join-uris
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-key.html"
							title="Utilities that read and write nested properties on objects and arrays.">
							can-key
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-key-tree.html"
							title="Store values in a tree structure.">
							can-key-tree
						</a>
						

					</li>
				
			
		
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-make-map.html"
							title="Convert a comma-separated string into a plain JavaScript object.">
							can-make-map
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-parse-uri.html"
							title="can-parse-uri">
							can-parse-uri
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-queues.html"
							title="A light weight queue system for scheduling tasks.">
							can-queues
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-string.html"
							title="String utilities.">
							can-string
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-string-to-any.html"
							title="Turns a string representation of a primitive type back into the associated primitive.">
							can-string-to-any
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-zone-storage.html"
							title="Implement Zone-safe memory-based storage">
							can-zone-storage
						</a>
						

					</li>
				
			
		
	</ul>


					</li>
				
			
		
			
				
					<li>
						<span>DOM Utilities</span>
						
	<ul>
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-ajax.html"
							title="Make an asynchronous HTTP (AJAX) request.">
							can-ajax
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-attribute-encoder.html"
							title="Encode and decode attribute names.">
							can-attribute-encoder
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-child-nodes.html"
							title="">
							can-child-nodes
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-control.html"
							title="Create organized, memory-leak free, rapidly performing, stateful controls with declarative event binding. Use Control to create UI controls like tabs, grids, and context menus, and organize them into higher-order business rules with can.route. It can serve as both a traditional view and a traditional controller.">
							can-control
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-dom-data.html"
							title="Associate key/value pair data with a DOM node in a memory-safe way.">
							can-dom-data
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-dom-events.html"
							title="Listen to DOM events and special events, and register special events.">
							can-dom-events
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-dom-mutate.html"
							title="Dispatch and listen for DOM mutations.">
							can-dom-mutate
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-event-dom-enter.html"
							title="Watch for when enter keys are pressed on a DomEventTarget.">
							can-event-dom-enter
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-event-dom-radiochange.html"
							title="A custom event for listening to changes of inputs with type &quot;radio&quot;, which fires when a conflicting radio input changes. A &quot;conflicting&quot; radio button has the same &quot;name&quot; attribute and exists within in the same form, or lack thereof. This event coordinates state bound to whether a radio is checked. The &quot;change&quot; event does not fire for deselected radios. By using this event instead, deselected radios receive notification.">
							can-event-dom-radiochange
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-fragment.html"
							title="Convert a String, HTMLElement, documentFragment, contentArray, or object with a can.toDOM symbol into a documentFragment.">
							can-fragment
						</a>
						

					</li>
				
			
		
	</ul>


					</li>
				
			
		
			
				
					<li>
						<span>Data Validation</span>
						
	<ul>
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-define-validate-validatejs.html"
							title="Adds validation methods and observables to a map using validate.js.">
							can-define-validate-validatejs
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-type.html"
							title="">
							can-type
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-validate.html"
							title="Shared utilities and type definitions to process validation errors.">
							can-validate
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-validate-interface.html"
							title="can-validate-interface provides simple property existence validation. Use to prevent errors resulting from missing properties on input objects.">
							can-validate-interface
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-validate-legacy.html"
							title="A plugin for CanJS that wraps any validation library to can.validate. Can-Validate doesn&#x27;t do any validation of its own but instead provides some abstraction to your library of choice. The chosen library is registered with can-validate using a shim.">
							can-validate-legacy
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-validate-validatejs.html"
							title="Create can-validate.validator functions using validate.js.">
							can-validate-validatejs
						</a>
						

					</li>
				
			
		
	</ul>


					</li>
				
			
		
			
				
					<li>
						<span>Typed Data</span>
						
	<ul>
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-cid.html"
							title="Utility for getting a unique identifier for an object.">
							can-cid
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-construct.html"
							title="Provides a way to easily use the power of prototypal inheritance without worrying about hooking up all the particulars yourself. Use can-construct.extend to create an inheritable constructor function of your own.">
							can-construct
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-construct-super.html"
							title="can.Construct.super is a plugin that makes it easier to call base functions from inside inheriting functions.">
							can-construct-super
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-data-types.html"
							title="A package of type objects that are used to test if a value is a member of the type and convert values to the type.">
							can-data-types
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-namespace.html"
							title="Namespace where can-* packages are registered.">
							can-namespace
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-reflect.html"
							title="Perform operations and read information on unknown data types.">
							can-reflect
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-reflect-dependencies.html"
							title="Functions to keep track of observable dependencies.">
							can-reflect-dependencies
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="function"
							href="can-reflect-promise.html"
							title="Expose an observable, Map-like API on Promise types.">
							can-reflect-promise
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-types.html"
							title="A stateful container for CanJS type information.">
							can-types
						</a>
						

					</li>
				
			
		
	</ul>


					</li>
				
			
		
			
				
					<li>
						<span>Polyfills</span>
						
	<ul>
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="can-symbol.html"
							title="Symbols used to detail how CanJS may operate on different objects CanJS has a consistent internal interface for objects to interact with each other, and this is also important for interop with external libraries.  CanJS uses symbols to identify object types, property access methods, and for event handling. can-symbol also has a polyfill function that will fake symbols on unsupported platforms.">
							can-symbol
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-vdom.html"
							title="A browser-lite environment for Node.js or a worker thread.">
							can-vdom
						</a>
						

					</li>
				
			
		
	</ul>


					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="can-core.html"
							title="The best, most hardened and generally useful libraries in CanJS.">
							Core
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						parent
           						">
						<a class="page"
							href="can-infrastructure.html"
							title="Utility libraries that power the core and ecosystem collection.">
							Infrastructure
						</a>
						
	<ul>
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-global.html"
							title="can-global">
							can-global
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="module"
							href="can-test-helpers.html"
							title="Common utilities for effectively testing the features of CanJS.">
							can-test-helpers
						</a>
						

					</li>
				
			
		
	</ul>


					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="can-ecosystem.html"
							title="Useful libraries that extend or add important features to the core collection.">
							Ecosystem
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="can-legacy.html"
							title="Former libraries that we still accept patches for, but are not under active development.">
							Legacy
						</a>
						

					</li>
				
			
		
	</ul>


					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="community.html"
							title="Get involved with one of the most inviting communities on the internet!">
							Community
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="guides/contribute.html"
							title="Learn how to contribute to CanJS!">
							Contributing
						</a>
						

					</li>
				
			
		
	</ul>


        
      </div>
      <div class="social-side-container">
        <ul class="social-side">
  <li>
    <a class="header-mobile github" href="https://github.com/canjs/canjs" target="_blank"><img class="social-icon-small" src="../docs/images/github.png">GitHub</a>
  </li>
  <li>
    <a class="header-mobile twitter" href="https://twitter.com/canjs" target="_blank"><img class="social-icon-small" src="../docs/images/twitter.png">Twitter</a>
  </li>
</ul>
<ul class="social-side">
  <li>
    <a class="header-mobile" href="https://www.bitovi.com/community/slack" target="_blank">Chat</a>
  </li>
  <li>
    <a class="header-mobile" href="https://forums.bitovi.com/c/canjs" target="_blank">Forum</a>
  </li>
</ul>
<ul class="social-side">
  <li>
    <a class="header-mobile" href="https://www.bitovi.com/blog/topic/canjs" target="_blank">News</a>
  </li>
  <li></li>
</ul>

      </div>
      <div class="by-bitovi-container">
        <a href="https://www.bitovi.com" target="_blank" class="bitovi by-bitovi">Bitovi</a>
      </div>

  </div>
  <div id="right" class="column">

      <article>
  <section class="title">
	<div class="page-type">
		<h1>can-component</h1>
			<ul class="title-social">
				
				<li>
					<a class="npm-button" href="https://www.npmjs.com/package/can-component">
						<img src="https://img.shields.io/badge/npm%20package-4.6.2-brightgreen.svg" alt="npm package badge" />
					</a>
				</li>
				<li>
					<a class="github-button nav-social" href="https://github.com/canjs/can-component" data-show-count="true">Star</a>
				</li>
				
				
				<li>
					<a class="button-link" href="//github.com/canjs/can-component/edit/master/docs/component.md">Edit on GitHub</a>
				</li>
				
			</ul>
	</div>
	<div class="clear-both"></div>
	
  
	<section class="description">
    <p>Create a custom element that can be used to manage widgets or application logic.</p>

</section>

  
	
</section>
<section class="on-this-page-table">
	<!--<h2 class="on-this-page-title" data-skip>Page Content</h2>-->
</section>







<div class="signature">
  <h2 class="signature-title">
    <code>Component</code>
  </h2>
  <p><code>can-component</code> exports a <code>Component</code> <a href="can-construct.html" title="Provides a way to easily use the power of prototypal inheritance
without worrying about hooking up all the particulars yourself. Use
can-construct.extend to create an inheritable
constructor function of your own.">Construct</a> constructor function used to
define custom elements.</p>
<p>Call <a href="can-component.extend.html" title="Define the behavior of a custom element.">Component.extend</a> to define a custom element. Components are
extended with a:</p>
<ul>
<li><a href="can-component.prototype.tag.html" title="Specifies the HTML tag (or node-name) the can-component will be created on.">tag</a> - The custom element tag name.</li>
<li><a href="can-component.prototype.ViewModel.html" title="Defines a class used to provide values and methods to the component’s view. The class is initialized with values specified by the component element’s data bindings.">ViewModel</a> - The methods and properties that manage the
logic of the component. This is usually a <a href="can-define/map/map.html" title="Create observable objects.">DefineMap</a> class.</li>
<li><a href="can-component.prototype.view.html" title="Provides a view to render directly within the component’s element. The view is rendered with the
component’s can-component::ViewModel instance.">view</a> - A template that writes the the inner HTML of
the custom element given the <code>ViewModel</code>. This is usually a <a href="can-stache.html" title="Live binding templates.">can-stache</a> template.</li>
</ul>
<p>The following defines a  <code>&lt;my-counter&gt;</code> element:</p>
<pre><code class="language-js">const MyCounter = Component.extend({
  tag: &quot;my-counter&quot;,
  view: `
    Count: &lt;span&gt;{{this.count}}&lt;/span&gt;
    &lt;button on:click=&quot;this.increment()&quot;&gt;+1&lt;/button&gt;
  `,
  ViewModel: {
    count: {default: 0},
    increment() {
      this.count++;
    }
  }
});
</code></pre>
<p>To create a component instance, either:</p>
<ul>
<li>Write the element <a href="can-component/component-element.html" title="Create a component using HTML and can-stache-bindings.">tag and bindings</a> in a <a href="can-stache.html" title="Live binding templates.">can-stache</a> template like:
<pre><code class="language-html">&lt;my-counter count:from=&quot;5&quot;/&gt;
</code></pre></li>
<li>Write the component tag in an HTML page and it will be mounted automatically:
<pre><code class="language-html">&lt;my-counter&gt;&lt;/my-counter&gt;
</code></pre></li>
<li>Create a <a href="can-component.new.html" title="Programmatically instantiate a component">new Component</a> programatically like:
<pre><code class="language-html">var myCounter = new MyCounter({
  viewModel: {
    count: 6
  }
});
myCounter.element   //-&gt; &lt;my-counter&gt;
myCounter.viewModel //-&gt; MyCounterVM{count:6}
</code></pre></li>
</ul>

  
  
  
</div>





  
    <section class="body">
    <h2>Purpose</h2>
<p><code>Component</code> is used to define custom elements.  Those custom elements are
used for many different layers within your application:</p>
<ul>
<li><strong>Application Component</strong> - A component that houses global state, for example <a href="can-route.data.html" title="An observable key-value object used to cross bind to the url observable can-route.urlData. Set it to cross-bind a top level state object (Application ViewModel) to can-route.">route data</a> and
session data, and selects different pages
based upon the url, session and other information.  Example: <code>&lt;my-app&gt;</code></li>
<li><strong>Page Component</strong> - Components that contain the functionality for a page.  Example: <code>&lt;todos-page&gt;</code></li>
<li>Functional Components - Component that provide functionality for a segment of a page.  Example: <code>&lt;todos-list&gt;</code>, <code>&lt;todos-create&gt;</code></li>
<li><strong>Widget/UI Components</strong> - Components that create controls that could be used many places. Example: <code>&lt;ui-slider&gt;</code>, <code>&lt;ui-tabs&gt;</code></li>
</ul>
<p><code>Component</code> is designed to be:</p>
<ul>
<li><p><strong>Testable</strong> - Components separate their logic into independently testable <a href="can-component.prototype.view.html" title="Provides a view to render directly within the component’s element. The view is rendered with the
component’s can-component::ViewModel instance.">view</a> and <a href="can-component.prototype.ViewModel.html" title="Defines a class used to provide values and methods to the component’s view. The class is initialized with values specified by the component element’s data bindings.">ViewModel</a> pieces.</p></li>
<li><p><strong>Flexible</strong> - There are many ways to manage logic in a component.  Components can be:</p>
<ul>
<li><em>dumb</em> - Get passed their data and can only call functions passed to them to change state.</li>
<li><em>smart</em> - Manage their own state and request data.</li>
</ul>
<p>Components can also:</p>
<ul>
<li>Access their DOM element through <a href="can-component/connectedCallback.html" title="A lifecycle hook called after the component's element is inserted into the document.">connectedCallback</a>. This is an escape hatch when
the <a href="can-component.prototype.view.html" title="Provides a view to render directly within the component’s element. The view is rendered with the
component’s can-component::ViewModel instance.">view</a> is unable to update the DOM in a way you need.</li>
<li>Support alternate <a href="can-component.prototype.ViewModel.html" title="Defines a class used to provide values and methods to the component’s view. The class is initialized with values specified by the component element’s data bindings.">ViewModel</a>s types like <a href="can-observe.html" title="Create observable objects, arrays, and functions that work like plain JavaScript objects, arrays, and functions.">can-observe</a>.</li>
</ul></li>
<li><p><strong>A bridge to web components</strong> - In browsers that support
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/customElements">custom elements</a>, <a href="can-component.extend.html" title="Define the behavior of a custom element.">extend</a> will create a custom element. We've also adopted many custom element
conventions such as:</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#Using_the_lifecycle_callbacks">connectedCallback</a> - Component's <a href="can-component/connectedCallback.html" title="A lifecycle hook called after the component's element is inserted into the document.">connectedCallback</a> lifecycle hook</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot">slots</a> - <a href="can-component/can-slot.html" title="Position the content of &lt;can-template&gt; elements.">&lt;can-slot&gt;</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template">template</a> - <a href="can-component/can-template.html" title="Pass templates declaratively to components.">&lt;can-slot&gt;</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/content">content</a> - <a href="can-component/content.html" title="Positions the LIGHT_DOM within a component’s can-component.prototype.view.">&lt;content&gt;</a> (<em>now obsolete</em>)</li>
</ul></li>
</ul>
<h2>Overview</h2>
<p>On a high level using <code>Component</code> is consists of two steps:</p>
<ol>
<li><p>Extend <code>Component</code> with a <a href="can-component.prototype.tag.html" title="Specifies the HTML tag (or node-name) the can-component will be created on.">tag</a>, <a href="can-component.prototype.view.html" title="Provides a view to render directly within the component’s element. The view is rendered with the
component’s can-component::ViewModel instance.">view</a>
and <a href="can-component.prototype.ViewModel.html" title="Defines a class used to provide values and methods to the component’s view. The class is initialized with values specified by the component element’s data bindings.">ViewModel</a> to create a custom element:</p>
<pre><code class="language-js">Component.extend({
  tag: &quot;my-counter&quot;,
  view: `
    Count: &lt;span&gt;{{this.count}}&lt;/span&gt;
    &lt;button on:click=&quot;this.increment()&quot;&gt;+1&lt;/button&gt;
  `,
  ViewModel: {
    count: {default: 0},
    increment() {
      this.count++;
    }
  }
});
</code></pre></li>
<li><p>Use that element in your HTML or within another <code>Component</code>'s <a href="can-component.prototype.view.html" title="Provides a view to render directly within the component’s element. The view is rendered with the
component’s can-component::ViewModel instance.">view</a> and
use <a href="can-stache-bindings.html" title="Listen to events and create one-way and two-way bindings.">can-stache-bindings</a> to pass values into or out of your component:</p>
<pre><code class="language-js">&lt;my-counter count:from=&quot;1&quot;/&gt;
</code></pre></li>
</ol>
<p>The following video walks through how this component works:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/3zMwoEuyX9g" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<h2>Learning how to use Component</h2>
<p>This section gives an overview of how to learn <code>Component</code>. As <code>Component</code>
is a combination of many other technologies, many of its parts are
documented in detail on other pages.</p>
<p>Begin learning <code>Component</code> by reading the <a href="guides/html.html" title="Learn how to update HTML and listen to user interactions.">HTML Guide</a> to get a background on <code>Component</code> and other related CanJS technology.</p>
<p>Learning <code>Component</code> mostly means learning:</p>
<ul>
<li><a href="can-define/map/map.html" title="Create observable objects.">DefineMap</a> which serves
as Component's <a href="can-component.prototype.ViewModel.html" title="Defines a class used to provide values and methods to the component’s view. The class is initialized with values specified by the component element’s data bindings.">ViewModel</a>s. A Component's ViewModel manages the
logic and state of the component.</li>
<li><a href="can-stache.html" title="Live binding templates.">stache</a> which serves as Component's <a href="can-component.prototype.view.html" title="Provides a view to render directly within the component’s element. The view is rendered with the
component’s can-component::ViewModel instance.">view</a>s. A
Component's view translates the ViewModel into HTML to display to the user.</li>
<li><a href="can-stache-bindings.html" title="Listen to events and create one-way and two-way bindings.">stacheBindings</a> which enable event binding and value passing between components and values in <a href="can-stache.html" title="Live binding templates.">can-stache</a> templates.</li>
</ul>
<p>The following are good resources to learn these parts:</p>
<h4>DefineMap</h4>
<p>Read the <a href="guides/logic.html" title="Learn how to write observables in an organized, maintainable, and testable way.">Logic Guide</a>  on how to:</p>
<ul>
<li>Organize ViewModel properties</li>
<li>Derive properties from other properties</li>
<li>Update the DOM when <a href="can-stache.html" title="Live binding templates.">stache</a> is unable to cause the change</li>
</ul>
<p>Checkout the <a href="guides/testing.html" title="Learn how to test CanJS applications.">Testing Guide</a> on how to test
ViewModels and components.</p>
<h4>stache</h4>
<p>Read <a href="can-stache.html" title="Live binding templates.">stache's documentation</a> on how to:</p>
<ul>
<li>Turn <code>ViewModel</code> values into HTML</li>
<li>Read promises</li>
<li>Animate HTML</li>
</ul>
<h4>stacheBindings</h4>
<p>Read <a href="can-stache-bindings.html" title="Listen to events and create one-way and two-way bindings.">stacheBindings</a> documentation on how to:</p>
<ul>
<li>Listen to events on elements or components and call a function.</li>
<li>Pass values between ViewModels and elements.</li>
</ul>
<p>The <a href="guides/forms.html" title="Learn how to create amazing &lt;form&gt;s with CanJS.">forms guide</a> details how to work with
forms and form elements.</p>
<h4>After the basics</h4>
<p>Once you've got a good understanding of how to write a ViewModel, a view and
pass values between them, this page is a good resource on how to do everything else
with Component.</p>
<p>For a summary of all of CanJS's core APIs, checkout the <a href="api.html" title="Welcome to the CanJS API documentation! This page is a CHEAT-SHEET for the most common APIs within CanJS. Read the
technology-overview page for background on the following APIs.">API page</a>.</p>
<h2>Basic Use</h2>
<p>The following sections cover:</p>
<ul>
<li><a href="#DefiningaComponent">Defining a component</a> with a
<a href="#DefiningaComponent_stag">tag</a>, <a href="#DefiningaComponent_sview">view</a> and <a href="#DefiningaComponent_sViewModel">ViewModel</a>.</li>
<li>Creating a component in one of the following ways:
<ul>
<li><a href="#Creatingacomponentinstache">In a stache template</a></li>
<li><a href="#CreatingacomponentinHTML">Directly in your HTML page</a></li>
<li><a href="l#Creatingacomponentprogrammatically">Programatically</a> with the component's constructor</li>
</ul></li>
<li>Component's lifecycle hooks</li>
</ul>
<h3>Defining a Component</h3>
<p>Use <a href="can-component.extend.html" title="Define the behavior of a custom element.">extend</a> to define a <code>Component</code> constructor function
that automatically gets initialized whenever the component’s tag is
found.</p>
<pre><code class="language-js">import {Component} from &quot;can&quot;;

const MyCounter = Component.extend({
  tag: &quot;my-counter&quot;,
  view: `
    Count: &lt;span&gt;{{this.count}}&lt;/span&gt;
    &lt;button on:click=&quot;this.increment()&quot;&gt;+1&lt;/button&gt;
  `,
  ViewModel: {
    count: {default: 0},
    increment() {
      this.count++;
    }
  }
});
</code></pre>
<h3>Defining a Component's tag</h3>
<p>A component’s <a href="can-component.prototype.tag.html" title="Specifies the HTML tag (or node-name) the can-component will be created on.">tag</a> is the element node name that
the component will be created on.  The tag should be hyphenated
as follows:</p>
<pre><code class="language-js">Component.extend( {
    tag: &quot;my-counter&quot;
} );
</code></pre>
<p>The previous component matches <code>&lt;my-counter&gt;</code> elements.</p>
<h3>Defining a Component's view</h3>
<p>A component’s <a href="can-component.prototype.view.html" title="Provides a view to render directly within the component’s element. The view is rendered with the
component’s can-component::ViewModel instance.">view</a> is a template that is rendered as the element’s innerHTML.</p>
<p>This is typically a <a href="can-stache.html" title="Live binding templates.">can-stache</a> template that is <a href="can-component.prototype.view.html#ImportingViews" title="Provides a view to render directly within the component’s element. The view is rendered with the
component’s can-component::ViewModel instance.">imported</a> or passed as a string.</p>
<p>The following component:</p>
<pre><code class="language-js">Component.extend({
  tag: &quot;my-counter&quot;,
  view: ` Count: &lt;span&gt;1&lt;/span&gt; `,
});
</code></pre>
<p>Changes <code>&lt;my-counter&gt;&lt;/my-counter&gt;</code> into:</p>
<pre><code class="language-html">&lt;my-counter&gt; Count: &lt;span&gt;1&lt;/span&gt; &lt;/my-counter&gt;
</code></pre>
<p>You can see by inspecting the DOM in the following example:</p>
<pre><code class="language-html">&lt;my-counter&gt;&lt;/my-counter&gt;
&lt;script type=&quot;module&quot;&gt;
import {Component} from &quot;can&quot;;

Component.extend({
  tag: &quot;my-counter&quot;,
  view: ` Count: &lt;span&gt;1&lt;/span&gt; `,
});
&lt;/script&gt;
</code></pre>
<div class='codepen'></div>
<p>The <code>view</code> is optional.  Read <a href="can-component.prototype.view.html#Omittingtheview" title="Provides a view to render directly within the component’s element. The view is rendered with the
component’s can-component::ViewModel instance.">here</a> what happens if it is omitted.</p>
<p>The <code>view</code> can also render the <a href="can-component/can-template.html" title="Pass templates declaratively to components.">&lt;can-template&gt; tags</a> passed to a
component using <a href="can-component/can-slot.html" title="Position the content of &lt;can-template&gt; elements.">&lt;can-slot&gt; tags</a>.  Read more about this in <a href="#Customizingacomponent_sview">Customizing a component's view</a>.</p>
<h3>Defining a Component's ViewModel</h3>
<p>A component’s <a href="can-component.prototype.ViewModel.html" title="Defines a class used to provide values and methods to the component’s view. The class is initialized with values specified by the component element’s data bindings.">ViewModel</a> defines a constructor that creates
instances used to render the component’s view. The <code>ViewModel</code> manages the logic
and state of a component.</p>
<p>The <code>ViewModel</code> can be defined separately
from the component.</p>
<pre><code class="language-js">import {Component, DefineMap} from &quot;can&quot;;

const MyCounterVM = DefineMap.extend(&quot;MyCounterVM&quot;,{
  count: {default: 0},
  increment() {
    this.count++;
  }
});

const MyCounter = Component.extend({
  tag: &quot;my-counter&quot;,
  view: `
    Count: &lt;span&gt;{{this.count}}&lt;/span&gt;
    &lt;button on:click=&quot;this.increment()&quot;&gt;+1&lt;/button&gt;
  `,
  ViewModel: MyCounterVM
});
</code></pre>
<div line-highlight='16'></div>
<p>In the previous example, <code>MyCounterVM</code> has state (the <code>count</code> property) and logic
(the <code>increment</code> method).  We could create a <code>MyCounterVM</code> instance ourselves,
read its state and call its methods as follows:</p>
<pre><code class="language-js">import {DefineMap} from &quot;can&quot;;

const MyCounterVM = DefineMap.extend(&quot;MyCounterVM&quot;,{
  count: {default: 0},
  increment() {
    this.count++;
  }
});

var myCounterVM = new MyCounterVM();

console.log( myCounterVM.count ) //-&gt; 0
myCounterVM.increment()
console.log( myCounterVM.count ) //-&gt; 1
</code></pre>
<div class='codepen'></div>
<div line-highlight='10-14,only'></div>
<p>Typically, the <code>ViewModel</code> is defined <em>inline</em> on the component, as an
object as follows:</p>
<pre><code class="language-js">import {Component, DefineMap} from &quot;can&quot;;

const MyCounter = Component.extend({
  tag: &quot;my-counter&quot;,
  view: `
    Count: &lt;span&gt;{{this.count}}&lt;/span&gt;
    &lt;button on:click=&quot;this.increment()&quot;&gt;+1&lt;/button&gt;
  `,
  ViewModel: {
    count: {default: 0},
    increment() {
      this.count++;
    }
  }
});
</code></pre>
<p>You can access the <code>ViewModel</code> created on the component constructor as follows:</p>
<pre><code class="language-js">import {Component, DefineMap} from &quot;can&quot;;

const MyCounter = Component.extend({
  tag: &quot;my-counter&quot;,
  view: `
    Count: &lt;span&gt;{{this.count}}&lt;/span&gt;
    &lt;button on:click=&quot;this.increment()&quot;&gt;+1&lt;/button&gt;
  `,
  ViewModel: {
    count: {default: 0},
    increment() {
      this.count++;
    }
  }
});

var myCounterVM = new MyCounter.ViewModel();

console.log( myCounterVM.count ) //-&gt; 0
myCounterVM.increment()
console.log( myCounterVM.count ) //-&gt; 1
</code></pre>
<div class='codepen'></div>
<div line-highlight='17,only'></div>
<h3>Creating a component in stache</h3>
<p>Components are usually created in the stache template of another component's view.</p>
<p>For example, a <code>&lt;my-counter/&gt;</code> element is created in the <code>&lt;my-app&gt;</code> component's view:</p>
<pre><code class="language-html">&lt;my-app&gt;&lt;/my-app&gt;
&lt;script type=&quot;module&quot;&gt;
import {Component} from &quot;can&quot;;

Component.extend({
  tag: &quot;my-counter&quot;,
  view: `
    Count: &lt;span&gt;{{this.count}}&lt;/span&gt;
    &lt;button on:click=&quot;this.increment()&quot;&gt;+1&lt;/button&gt;
  `,
  ViewModel: {
    count: {default: 0},
    increment() {
      this.count++;
    }
  }
});

Component.extend({
  tag: &quot;my-app&quot;,
  view: `&lt;my-counter/&gt;`
});
&lt;/script&gt;
</code></pre>
<div class='codepen'></div>
<div line-highlight='21'></div>
<p>In stache, components can be written as self closing (like <code>&lt;my-counter/&gt;</code>)
or have a closing tag (like <code>&lt;my-counter&gt;&lt;/my-counter&gt;</code>).</p>
<p><a href="can-stache-bindings.html" title="Listen to events and create one-way and two-way bindings.">Data and event bindings</a> can be added to components to communicate across
components.  The following cross binds <code>&lt;my-app&gt;</code>'s <code>number</code>  with <code>&lt;my-counter&gt;</code>'s <code>count</code>:</p>
<pre><code class="language-html">&lt;my-app&gt;&lt;/my-app&gt;
&lt;script type=&quot;module&quot;&gt;
import {Component} from &quot;can&quot;;

Component.extend({
  tag: &quot;my-counter&quot;,
  view: `
    Count: &lt;span&gt;{{this.count}}&lt;/span&gt;
    &lt;button on:click=&quot;this.increment()&quot;&gt;+1&lt;/button&gt;
  `,
  ViewModel: {
    count: {default: 0},
    increment() {
      this.count++;
    }
  }
});

Component.extend({
  tag: &quot;my-app&quot;,
  view: `
    Your Number is {{this.number}}.&lt;br/&gt;
    &lt;my-counter count:bind=&quot;this.number&quot;/&gt;
  `,
  ViewModel: {
    number: {default: 4}
  }
});
&lt;/script&gt;

</code></pre>
<div class='codepen'></div>
<div line-highlight='23,only'></div>
<p>Read the <a href="can-component/component-element.html" title="Create a component using HTML and can-stache-bindings.">&lt;tag bindings...&gt;</a> docs for more information
on what's available when creating components in stache, including:</p>
<ul>
<li>The <a href="can-stache-bindings.html" title="Listen to events and create one-way and two-way bindings.">bindings</a> available.</li>
<li>Passing <a href="can-component/can-template.html" title="Pass templates declaratively to components.">&lt;can-template&gt; elements</a>.</li>
</ul>
<h3>Creating a component in HTML</h3>
<p>Component elements can also be inserted directly in the page. For
example, the following creates two <code>&lt;my-counter&gt;</code> elements in the page:</p>
<pre><code class="language-html">&lt;p&gt;&lt;my-counter&gt;&lt;/my-counter&gt;&lt;/p&gt;
&lt;p&gt;&lt;my-counter&gt;&lt;/my-counter&gt;&lt;/p&gt;

&lt;script type=&quot;module&quot;&gt;
import {Component} from &quot;can&quot;;

Component.extend({
  tag: &quot;my-counter&quot;,
  view: `
    Count: &lt;span&gt;{{this.count}}&lt;/span&gt;
    &lt;button on:click=&quot;this.increment()&quot;&gt;+1&lt;/button&gt;
  `,
  ViewModel: {
    count: {default: 0},
    increment() {
      this.count++;
    }
  }
});
&lt;/script&gt;

</code></pre>
<div class='codepen'></div>
<div line-highlight='1-2'></div>
<p>Compared to components created in <code>stache</code>, components created directly in HTML have a number of restrictions that are enumerated
<a href="can-component/component-element.html#DifferencesbetweencomponentsinstacheandHTML" title="Create a component using HTML and can-stache-bindings.">here</a>.</p>
<h3>Creating a component programmatically</h3>
<p><a href="can-component.extend.html" title="Define the behavior of a custom element.">Component.extend</a> returns a constructor function. These are
often used for <a href="guides/testing.html" title="Learn how to test CanJS applications.">testing</a> and <a href="guides/routing.html" title="Learn how to make your application respond to changes in the URL and work with the browser’s back and forward buttons.">Routing</a>. It's used for dynamically
selecting a component in the <a href="guides/recipes/modals.html" title="This intermediate guide shows how to create a multiple modal form.">Multiple Modals</a> recipe.</p>
<p>The following dynamically switches between two components:</p>
<pre><code class="language-html">&lt;my-app&gt;&lt;/my-app&gt;

&lt;script type=&quot;module&quot;&gt;
import {Component} from &quot;can&quot;;

const GreenLight = Component.extend({
    tag: &quot;green-light&quot;,
    view: `💚`
});

const RedLight = Component.extend({
    tag: &quot;red-light&quot;,
    view: `❤️`
});

Component.extend({
    tag: &quot;my-app&quot;,
    view: `
        &lt;button on:click=&quot;this.color = 'red'&quot;&gt;Red&lt;/button&gt;
        &lt;button on:click=&quot;this.color = 'green'&quot;&gt;Green&lt;/button&gt;
        Color: {{component}}.
    `,
    ViewModel: {
        green: {
            default: () =&gt; new GreenLight()
        },
        red: {
            default: () =&gt; new RedLight()
        },
        color: {default: &quot;green&quot;},
        get component(){
            if(this.color === &quot;green&quot;) {
                return this.green;
            } else {
                return this.red;
            }
        }
    }
});
&lt;/script&gt;
</code></pre>
<div class='codepen'></div>
<p>Read more about how to programmatically create components on the <a href="can-component.new.html" title="Programmatically instantiate a component">new Component</a> page.</p>
<h3>Lifecycle / Timing</h3>
<p>Components have a lifecycle of method calls that you can hook into
to perform various setup and teardown actions.</p>
<p>The following <code>&lt;lifecycle-component&gt;</code>
component logs the timing of various activities.  The <code>&lt;my-app&gt;</code> component
will add and remove <code>&lt;lifecycle-component&gt;</code> from the page so you can see
when the bindings are called.  Also, <code>&lt;lifecycle-component&gt;</code>'s <code>childProperty</code>
is two-way bound to <code>&lt;my-app&gt;</code>'s <code>parentProperty</code>.</p>
<pre><code class="language-html">&lt;my-app&gt;&lt;/my-app&gt;

&lt;script type=&quot;module&quot;&gt;
import {Component, stache, DefineMap} from &quot;can&quot;;

var view = stache(&quot;Added Lifecycle Component&quot;);

Component.extend({
    tag: &quot;lifecycle-component&quot;,
    view: function(){
        console.log(&quot;before the view is rendered&quot;);
        var fragment = view.apply(this, arguments);
        console.log(&quot;after the view is rendered&quot;);
        return fragment;
    },
    ViewModel: {
        setup: function(props){
            console.log(&quot;before properties are set on the ViewModel&quot;);
            return DefineMap.prototype.setup.apply(this, arguments);
        },
        init: function(){
            console.log(&quot;after initial properties are set on the ViewModel&quot;);
        },
        connectedCallback(element) {
            console.log(&quot;after the element is inserted in the page&quot;);

            return () =&gt; {
                console.log(&quot;after the element is removed from the page&quot;);
                this.stopListening();
            };
        },
        childProperty: {
            value( {resolve} ){
                console.log(&quot;childProperty bound and read&quot;);
                resolve(&quot;childProperty&quot;);
                return function(){
                    console.log(&quot;childProperty unbound&quot;);
                }
            }
        }
    }
});

Component.extend({
    tag: &quot;my-app&quot;,
    view: `
        &lt;button on:click=&quot;this.toggle()&quot;&gt;
            {{# if(this.show) }} Remove {{else}} Add {{/}} Component
        &lt;/button&gt;
        {{# if(this.show) }}
            &lt;lifecycle-component childProperty:bind=&quot;this.parentProperty&quot;/&gt;
        {{else}}
            Removed Lifecycle Component
        {{/}}
    `,
    ViewModel: {
        show: {default: false},
        toggle(){
            this.show = !this.show;
        },
        parentProperty: {
            value( {resolve} ){
                console.log(&quot;parentProperty bound and read&quot;);
                resolve(&quot;parentProperty&quot;);
                return function(){
                    console.log(&quot;parentProperty unbound&quot;);
                }
            }
        }
    }
})
&lt;/script&gt;
</code></pre>
<div class='codepen'></div>
<div line-highlight='11,13,18,22,25,28,34,37,63,66'></div>
<p>When <code>&lt;lifecycle-component&gt;</code> is added to the page, the following will be logged:</p>
<ol>
<li><strong>parentProperty bound and read</strong> - When a component is created, we will initialize the
<code>ViewModel</code> with component bindings  (<a href="can-stache-bindings.toChild.html" title="One-way bind a value in the parent scope to the ViewModel or element.">key:from</a> or <a href="can-stache-bindings.twoWay.html" title="Two-way bind a value in the viewModel or the element to the parent scope.">key:bind</a>) that read
from the scope. Before anything else happens, the right hand side of bindings like <code>childProperty:bind=&quot;this.parentProperty&quot;</code> will be bound and read to be prepared to initialize
a new <code>ViewModel</code>.</li>
<li><strong>before properties are set on the ViewModel</strong> - As <a href="can-define/map/map.html" title="Create observable objects.">DefineMap</a> inherits from
<a href="can-construct.html" title="Provides a way to easily use the power of prototypal inheritance
without worrying about hooking up all the particulars yourself. Use
can-construct.extend to create an inheritable
constructor function of your own.">Construct</a>, you can overwrite initialization behavior in <a href="can-construct.prototype.setup.html" title="">setup</a>
and <a href="can-construct.prototype.init.html" title="Called when a new instance of a Construct is created.">init</a>. DefineMap's <code>setup</code> function will set all properties on the
<code>ViewModel</code>. <code>setup</code> can use <a href="can-construct.ReturnValue.html" title="Use to overwrite the return value of new Construct(...).">ReturnValue</a> to return alternative instances.</li>
<li><strong>after initial properties are set on the ViewModel</strong> - Once all initial properties are set on
the <code>ViewModel</code>, the <code>ViewModel</code>'s <a href="can-construct.prototype.init.html" title="Called when a new instance of a Construct is created.">init</a> method will be called. This can
be a good time to make sure the ViewModel is ready for being passed to the view.</li>
<li><strong>childProperty bound and read</strong> - Once the <code>ViewModel</code> is created, any component bindings that
read the ViewModel will be bound and (<a href="can-stache-bindings.toParent.html" title="One-way bind a value from the viewModel or element to the parent scope.">key:to</a> or <a href="can-stache-bindings.twoWay.html" title="Two-way bind a value in the viewModel or the element to the parent scope.">key:bind</a>)
read. At this time, the parent binding value might be updated.</li>
<li><strong>before the view is rendered</strong> - The component's <code>view</code> function will be called with the <code>ViewModel</code>.</li>
<li><strong>after the view is rendered</strong> - After the <code>view</code> is rendered, the result will be a document fragment that
is not attached to the page.</li>
<li><strong>after the element is inserted in the page</strong> - The document fragment has been inserted within the component
element and the component element has been inserted into the document. This is a good place to
setup any stateful side effects as shown in the <a href="guides/logic.html" title="Learn how to write observables in an organized, maintainable, and testable way.">Logic guide</a> or read the DOM.</li>
</ol>
<p>When <code>&lt;lifecycle-component&gt;</code> is removed from the page, the following will be logged:</p>
<ol>
<li><strong>parentProperty unbound</strong> - When the element is removed, its bindings are town down immediately, starting
with the parent value of a binding.</li>
<li><strong>childProperty unbound</strong> - Next, the child value of the parent is town down.</li>
<li><strong>after the element is removed from the page</strong>  - Finally the <code>disconnectedCallback</code> is called.</li>
</ol>
<h2>Other Uses</h2>
<p>The following shows (or links to) how to solve common use cases.</p>
<h3>Customizing a component's layout</h3>
<p>Often, you want to allow consumers of a component to adjust the HTML of
a component. There are two ways of doing this:</p>
<ul>
<li>Using <code>&lt;can-slot&gt;</code> and <code>&lt;can-template&gt;</code>.</li>
<li>Passing a <code>view</code></li>
</ul>
<h4>Slots and templates</h4>
<p><a href="can-component/can-template.html" title="Pass templates declaratively to components.">&lt;can-template&gt;</a> Allows you to pass a view to
a component's view where its content can be inserted with a corresponding
<a href="can-component/can-slot.html" title="Position the content of &lt;can-template&gt; elements.">&lt;can-slot&gt;</a> as follows:</p>
<pre><code class="language-html">&lt;my-app&gt;&lt;/my-app&gt;
&lt;script type=&quot;module&quot;&gt;
import {Component} from &quot;can&quot;;

Component.extend({
    tag: &quot;hello-world&quot;,
    view: `
        {{# if(this.show) }}
            &lt;can-slot name=&quot;helloGreeting&quot;
                message:from=&quot;this.message&quot;/&gt;
        {{/ if }}
    `,
    ViewModel: {
        show: {
            value({resolve}){
                var show = resolve(true);
                var interval = setInterval( () =&gt; resolve(show = !show), 1000);
                return () =&gt; clearInterval(interval);
            }
        },
        message: {default: &quot;world&quot;}
    }
});

Component.extend({
    tag: &quot;my-app&quot;,
    view: `
        &lt;hello-world&gt;
            &lt;can-template name=&quot;helloGreeting&quot;&gt;
                &lt;h1&gt;Hello {{message}}!&lt;/h1&gt;
            &lt;/can-template&gt;
        &lt;/hello-world&gt;
    `
})
&lt;/script&gt;
</code></pre>
<div class='codepen'></div>
<div line-highlight='9-10,29-31,only'></div>
<p>Read <a href="can-component/can-slot.html" title="Position the content of &lt;can-template&gt; elements.">&lt;can-slot&gt;</a>'s documentation for more information on this
technique.</p>
<h4>Passing a view</h4>
<p>There are two common ways of creating an passing a view:</p>
<ul>
<li>Creating an <a href="can-stache.tags.named-partial.html" title="Create an inline named partial within the current template.">inline partial</a>.</li>
<li>Creating a view programmatically as a property value.</li>
</ul>
<p>The following creates a <code>helloGreeting</code> inline partial and passes it to
<code>&lt;hello-world&gt;</code> to be rendered.</p>
<pre><code class="language-html">&lt;my-app&gt;&lt;/my-app&gt;
&lt;script type=&quot;module&quot;&gt;
import {Component} from &quot;can&quot;;

Component.extend({
    tag: &quot;hello-world&quot;,
    view: `
        {{# if(this.show) }}
            {{ greeting(this) }}
        {{/ if }}
    `,
    ViewModel: {
        show: {
            value({resolve}){
                var show = resolve(true);
                var interval = setInterval( () =&gt; resolve(show = !show), 1000);
                return () =&gt; clearInterval(interval);
            }
        },
        greeting: &quot;any&quot;,
        message: {default: &quot;world&quot;}
    }
});

Component.extend({
    tag: &quot;my-app&quot;,
    view: `
        {{&lt;helloGreeting}}
        &lt;h1&gt;Hello {{message}}!&lt;/h1&gt;
        {{/helloGreeting}}

        &lt;hello-world greeting:from=&quot;helloGreeting&quot;/&gt;
    `
})
&lt;/script&gt;
</code></pre>
<div class='codepen'></div>
<div line-highlight='9,28-32,only'></div>
<p>The following does the same thing, but creates <code>this.helloGreeting</code> as a ViewModel property:</p>
<pre><code class="language-html">&lt;my-app&gt;&lt;/my-app&gt;
&lt;script type=&quot;module&quot;&gt;
import {Component, stache} from &quot;can&quot;;

Component.extend({
    tag: &quot;hello-world&quot;,
    view: `
        {{# if(this.show) }}
            {{ greeting(this) }}
        {{/ if }}
    `,
    ViewModel: {
        show: {
            value({resolve}){
                var show = resolve(true);
                var interval = setInterval( () =&gt; resolve(show = !show), 1000);
                return () =&gt; clearInterval(interval);
            }
        },
        greeting: &quot;any&quot;,
        message: {default: &quot;world&quot;}
    }
});

Component.extend({
    tag: &quot;my-app&quot;,
    view: `
        &lt;hello-world greeting:from=&quot;this.helloGreeting&quot;/&gt;
    `,
    ViewModel: {
        helloGreeting: {
            default: ()=&gt; stache(`&lt;h1&gt;Hello {{message}}!&lt;/h1&gt;`)
        }
    }
})
&lt;/script&gt;
</code></pre>
<div class='codepen'></div>
<div line-highlight='9,28,31-33,only'></div>
<h3>Debugging Components</h3>
<p>Read the <a href="guides/debugging.html" title="Learn how to debug CanJS applications.">Debugging</a> guide to learn how to solve
common issues with components.</p>
<h3>Inheriting Components</h3>
<p>Read the <a href="can-component.extend.html#InheritingComponents" title="Define the behavior of a custom element.">extend docs on inheriting</a> for how to
inherit from a base component.</p>
<h3>Manipulating or reading the DOM outside the view</h3>
<p>The <a href="can-stache.html" title="Live binding templates.">stache</a> view should be how your component interacts with the DOM the <em>vast</em> majority of the
time.  However, sometimes it's not able to do everything you need. In these circumstances you should
use <a href="can-component/connectedCallback.html" title="A lifecycle hook called after the component's element is inserted into the document.">connectedCallback</a> to get the component's element and do what you need.</p>
<p>The <a href="can-component.html#Slider" title="Create a custom element that can be used to manage widgets or application logic.">Slider example</a> shows using <a href="can-component/connectedCallback.html" title="A lifecycle hook called after the component's element is inserted into the document.">connectedCallback</a> to update a
component's <code>width</code> property when the page is resized.</p>
<pre><code class="language-js">connectedCallback(el) {
    // derive the width
    this.width = width(el) - el.firstElementChild.offsetWidth;
    this.listenTo(window,&quot;resize&quot;, () =&gt; {
        this.width = width(el) - el.firstElementChild.offsetWidth;
    });
    ...
}
</code></pre>
<p>The <a href="guides/recipes/video-player.html" title="This beginner guide walks you through building custom video controls around a video element.">Video Player</a> recipe shows calling <code>.play()</code> or <code>.pause()</code> on
a <code>&lt;video&gt;</code> element when the component's <code>playing</code> state changes:</p>
<pre><code class="language-js">connectedCallback(element) {
  this.listenTo(&quot;playing&quot;, function(event, isPlaying) {
    if (isPlaying) {
      element.querySelector(&quot;video&quot;).play();
    } else {
      element.querySelector(&quot;video&quot;).pause();
    }
  });
  ...
}
</code></pre>
<!--
### Binding nested observable values
### Causing effects when a component is removed
-->
<h2>Examples</h2>
<p>Check out the following examples built with <code>Component</code>.</p>
<h3>Slider</h3>
<p>The following creates a draggable slider. It uses <a href="can-component/connectedCallback.html" title="A lifecycle hook called after the component's element is inserted into the document.">connectedCallback</a>
to update the component's <code>width</code> when the page is resized.</p>
<pre><code class="language-html">&lt;percent-slider value:from=&quot;50&quot;&gt;&lt;/percent-slider&gt;
&lt;script type=&quot;module&quot;&gt;
import { Component } from &quot;can&quot;;

function width(el) {
    var cs = window.getComputedStyle(el,null)
    return el.clientWidth - parseFloat( cs.getPropertyValue(&quot;padding-left&quot;) )
        - parseFloat( cs.getPropertyValue(&quot;padding-left&quot;) );
}

Component.extend({
    tag: &quot;percent-slider&quot;,
    view: `
        &lt;div class='slider'
          style=&quot;left: {{ left }}px&quot;
          on:mousedown='startDrag(scope.event.clientX)'/&gt;`,

    ViewModel: {
        start: {type: &quot;number&quot;, default: 0},
        end: {type: &quot;number&quot;, default: 100},
        currentValue: {
            default: function(){
                return this.value || 0;
            }
        },
        width: {type: &quot;number&quot;, default: 0},
        get left(){
            var left = this.currentValue / this.end * this.width;
            return Math.min( Math.max(0, left), this.width) || 0;
        },
        connectedCallback(el) {
            // derive the width
            this.width = width(el) - el.firstElementChild.offsetWidth;
            this.listenTo(window,&quot;resize&quot;, () =&gt; {
                this.width = width(el) - el.firstElementChild.offsetWidth;
            });

            // Produce dragmove and dragup events on the view-model
            this.listenTo(&quot;startClientX&quot;, () =&gt; {
                var startLeft = this.left;
                this.listenTo(document,&quot;mousemove&quot;, (event)=&gt;{
                    this.dispatch(&quot;dragmove&quot;, [event.clientX - this.startClientX + startLeft]);
                });
                this.listenTo(document,&quot;mouseup&quot;, (event)=&gt;{
                    this.dispatch(&quot;dragup&quot;, [event.clientX - this.startClientX + startLeft]);
                    this.stopListening(document);
                })
            });
            // Update the slider position when currentValue changes
            this.listenTo(&quot;dragmove&quot;, (ev, left)=&gt; {
                this.currentValue = (left / this.width) * (this.end - this.start);
            },&quot;notify&quot;);

            // If the value is set, update the current value
            this.listenTo(&quot;value&quot;, (ev, newValue) =&gt; {
                this.currentValue = newValue;
            }, &quot;notify&quot;);

            // Update the value on a dragmove
            this.listenTo(&quot;dragup&quot;, (ev, left)=&gt; {
                this.value = (left / this.width) * (this.end - this.start);
            },&quot;notify&quot;);

            return this.stopListening.bind(this);
        },
        startClientX: &quot;any&quot;,
        startDrag(clientX) {
            this.startClientX = clientX;
        }

    }
});
&lt;/script&gt;
&lt;style&gt;
.slider {
    border: solid 1px blue;
    background-color: red;
    height: 40px;
    width: 40px;
    cursor: ew-resize;
    position: relative;
}
percent-slider {
    border: solid 4px black;
    padding: 5px;
    display: block;
}
&lt;/style&gt;

</code></pre>
<div class='codepen'></div>
<div line-highlight='33-36,only'></div>
<h3>Tabs</h3>
<p>The following demos a tabs widget.  Click “Add Vegetables”
to add a new tab.</p>
<div class='demo_wrapper' data-demo-src='demos/can-component/tabs.html'></div>
<p>An instance of the tabs widget is created by creating <code>&lt;my-tabs&gt;</code> and <code>&lt;my-panel&gt;</code>
elements like:</p>
<pre><code class="language-html">&lt;my-tabs&gt;
    {{#each(foodTypes)}}
        &lt;my-panel title:from=&quot;title&quot;&gt;{{content}}&lt;/my-panel&gt;
    {{/each}}
&lt;/my-tabs&gt;
</code></pre>
<p>To add another panel, all we have to do is add data to <code>foodTypes</code> like:</p>
<pre><code class="language-js">foodTypes.push( {
    title: &quot;Vegetables&quot;,
    content: &quot;Carrots, peas, kale&quot;
} );
</code></pre>
<p>The secret is that the <code>&lt;my-panel&gt;</code> element listens to when it is inserted
and adds its data to the tabs’ list of panels with:</p>
<pre><code class="language-js">const vm = this.parentViewModel = canViewModel( this.element.parentNode );
vm.addPanel( this.viewModel );
</code></pre>
<h3>TreeCombo</h3>
<p>The following tree combo lets people walk through a hierarchy and select locations.</p>
<div class='demo_wrapper' data-demo-src='demos/can-component/treecombo.html'></div>
<p>The secret to this widget is the viewModel’s <code>breadcrumb</code> property, which is an array
of items the user has navigated through, and <code>selectableItems</code>, which represents the children of the
last item in the breadcrumb.  These are defined on the viewModel like:</p>
<pre><code class="language-js">DefineMap.extend( {
    breadcrumb: {
        Default: DefineList
    },
    selectableItems: {
        get: function() {
            const breadcrumb = this.breadcrumb;

            // if there’s an item in the breadcrumb
            if ( breadcrumb.length ) {

                // return the last item’s children
                const i = breadcrumb.length - 1;
                return breadcrumb[ i ].children;
            } else {

                // return the top list of items
                return this.items;
            }
        }
    }
} );
</code></pre>
<p>When the “+” icon is clicked next to each item, the viewModel’s <code>showChildren</code> method is called, which
adds that item to the breadcrumb like:</p>
<pre><code class="language-js">DefineMap.extend( {
    showChildren: function( item, ev ) {
        ev.stopPropagation();
        this.breadcrumb.push( item );
    }
} );
</code></pre>
<h3>Paginate</h3>
<p>The following example shows 3
widget-like components: a grid, next / prev buttons, and a page count indicator. And, it shows an application component that puts them all together.</p>
<div class='demo_wrapper' data-demo-src='demos/can-component/paginate.html'></div>
<p>This demo uses a <code>Paginate</code> <a href="can-define/map/map.html" title="Create observable objects.">can-define/map/map</a> to assist with maintaining a paginated state:</p>
<pre><code class="language-js">const Paginate = DefineMap.extend( {

    // ...
} );
</code></pre>
<p>The <code>app</code> component, using <a href="can-define/map/map.html" title="Create observable objects.">can-define/map/map</a>, creates an instance of the <code>Paginate</code> model
and a <code>websitesPromise</code> that represents a request for the Websites
that should be displayed.  Notice how the <code>websitesCount</code> value is updated when
the <code>websitesPromise</code> resolves. <a href="can-component/connectedCallback.html" title="A lifecycle hook called after the component's element is inserted into the document.">connectedCallback</a> is used to
listen for changes to <code>websitesCount</code>, which then updates the paginate’s <code>count</code>
value.</p>
<pre><code class="language-js">const AppViewModel = DefineMap.extend( {
    connectedCallback: function() {
        this.listenTo( &quot;websitesCount&quot;, function( event, count ) {
            this.paginate.count = count;
        } );
        return this.stopListening.bind( this );
    },
    paginate: {
        default: function() {
            return new Paginate( {
                limit: 5
            } );
        }
    },
    websitesCount: {
        get: function( lastValue, setValue ) {
            this.websitesPromise.then( function( websites ) {
                setValue( websites.count );
            } );
        }
    },
    websitesPromise: {
        get: function() {
            return Website.getList( {
                limit: this.paginate.limit,
                offset: this.paginate.offset
            } );
        }
    }
} );
</code></pre>
<p>The <code>my-app</code> component passes paginate, paginate’s values, and websitesPromise to
its sub-components:</p>
<pre><code class="language-html">&lt;my-app&gt;
    &lt;my-grid promiseData:from=&quot;websitesPromise&quot;&gt;
        {{#each(items)}}
            &lt;tr&gt;
                &lt;td width=&quot;40%&quot;&gt;{{name}}&lt;/td&gt;
                &lt;td width=&quot;70%&quot;&gt;{{url}}&lt;/td&gt;
            &lt;/tr&gt;
        {{/each}}
    &lt;/my-grid&gt;
    &lt;next-prev paginate:from=&quot;paginate&quot;&gt;&lt;/next-prev&gt;
    &lt;page-count page:from=&quot;paginate.page&quot; count:from=&quot;paginate.pageCount&quot;&gt;&lt;/page-count&gt;
&lt;/my-app&gt;
</code></pre>

</section>

  


<script type="text/javascript">
  window.docObject = {"src":{"path":"node_modules/can-component/docs/component.md"},"description":"Create a custom element that can be used to manage widgets or application logic.\n\n","type":"module","title":"can-component","types":[{"type":"constructor"}],"name":"can-component","download":"can/component","test":"can/component/test.html","parent":"can-views","collection":"can-core","release":"2.0","link":"../docco/component/component.html docco","package":{"author":{"name":"Bitovi","email":"contact@bitovi.com","url":"http://bitovi.com"},"bugs":{"url":"https://github.com/canjs/can-component/issues"},"bundleDependencies":false,"dependencies":{"can-assign":"^1.1.1","can-bind":"^1.4.0","can-child-nodes":"^1.0.0","can-construct":"^3.2.0","can-control":"^4.0.0","can-define":"^2.0.0","can-dom-data":"^1.0.1","can-dom-events":"^1.1.0","can-dom-mutate":"^1.0.0","can-fragment":"^1.0.0","can-globals":"^1.0.0","can-log":"^1.0.0","can-namespace":"1.0.0","can-observation":"^4.0.0","can-observation-recorder":"^1.2.0","can-queues":"^1.0.0","can-reflect":"^1.6.0","can-simple-map":"^4.1.0","can-simple-observable":"^2.0.0","can-stache":"^4.10.0","can-stache-bindings":"^4.9.0","can-stache-key":"^1.0.0","can-string":"<2.0.0","can-symbol":"^1.4.1","can-view-callbacks":"^4.2.0","can-view-model":"^4.0.0","can-view-nodelist":"^4.1.0","can-view-scope":"^4.7.0"},"deprecated":false,"description":"Custom elements for CanJS","devDependencies":{"can-observe":"^2.0.0","can-test-helpers":"^1.1.2","can-value":"<2.0.0","can-vdom":"^4.0.0","detect-cyclic-packages":"^1.1.0","docco":"^0.8.0","done-serve":"^2.0.0","gh-pages":"^2.0.1","highlight.js":"9.12.0","jshint":"^2.9.1","steal":"^1.0.0","steal-qunit":"^2.0.0","steal-tools":"^1.0.1","testee":"^0.9.0"},"homepage":"https://canjs.com/doc/can-component.html","keywords":["canjs","canjs-plugin","donejs"],"main":"can-component","name":"can-component","repository":{"type":"git","url":"git://github.com/canjs/can-component.git"},"scripts":{"detect-cycle":"detect-cyclic-packages --ignore done-serve","develop":"done-serve --static --develop --port 8080","docco":"docco -o docco can-component.js","docco:publish":"npm run docco && gh-pages -d docco","jshint":"jshint ./*.js test/*.js --config","postpublish":"git push --tags && git push","preversion":"npm test","release:major":"npm version major && npm publish","release:minor":"npm version minor && npm publish","release:patch":"npm version patch && npm publish","release:pre":"npm version prerelease && npm publish --tag=pre","test":"npm run detect-cycle && npm run jshint && npm run testee","testee":"testee test/test.html --browsers firefox"},"system":{"configDependencies":["live-reload"]},"version":"4.6.2"},"outline":{"depth":2},"signatures":[{"code":"Component","description":"\n\n  `can-component` exports a `Component` [can-construct Construct] constructor function used to\n  define custom elements.\n\n  Call [can-component.extend Component.extend] to define a custom element. Components are\n  extended with a:\n\n  - [can-component.prototype.tag] - The custom element tag name.\n  - [can-component.prototype.ViewModel] - The methods and properties that manage the\n    logic of the component. This is usually a [can-define/map/map DefineMap] class.\n  - [can-component.prototype.view] - A template that writes the the inner HTML of\n    the custom element given the `ViewModel`. This is usually a [can-stache] template.\n\n  The following defines a  `<my-counter>` element:\n\n  ```js\n  const MyCounter = Component.extend({\n    tag: \"my-counter\",\n    view: `\n      Count: <span>{{this.count}}</span>\n      <button on:click=\"this.increment()\">+1</button>\n    `,\n    ViewModel: {\n      count: {default: 0},\n      increment() {\n        this.count++;\n      }\n    }\n  });\n  ```\n\n  To create a component instance, either:\n\n  - Write the element [can-component/component-element tag and bindings] in a [can-stache] template like:\n    ```html\n    <my-counter count:from=\"5\"/>\n    ```\n  - Write the component tag in an HTML page and it will be mounted automatically:\n    ```html\n    <my-counter></my-counter>\n    ```\n  - Create a [can-component.new] programatically like:\n    ```html\n    var myCounter = new MyCounter({\n      viewModel: {\n        count: 6\n      }\n    });\n    myCounter.element   //-> <my-counter>\n    myCounter.viewModel //-> MyCounterVM{count:6}\n    ```\n","params":[]}],"comment":" ","codepen":[["\"can\"","\"//unpkg.com/can@5/core.mjs\""],["\"can/everything\"","\"//unpkg.com/can@5/everything.mjs\""],["\"can/demos/technology-overview/mock-url\"","\"//unpkg.com/mock-url@^5.0.0/mock-url.mjs\""],["\"can/demos/technology-overview/route-mini-app-components\"","\"//unpkg.com/route-mini-app@^5.0.0/components.mjs\""],["return steal.import(","return import("],["\"can/demos/technology-overview/page-login\"","\"//unpkg.com/route-mini-app@^5.0.0/page-login.mjs\""],["`can/demos/technology-overview/page-${this.page}`","`//unpkg.com/route-mini-app@^5.0.0/page-${this.page}.mjs`"]],"pathToRoot":".."};
</script>
</article>
      
        <footer><p>CanJS is part of <a href="https://donejs.com" target="_blank">DoneJS</a>. Created and maintained by the core <a href="https://donejs.com/About.html#team" target="_blank">DoneJS team</a> and <a href="https://www.bitovi.com" target="_blank">Bitovi</a>. <strong>Currently 5.33.3.</strong></p>
</footer>
      

  </div>
  <div id="toc-sidebar" class="column">
    <nav>
      <h1 class="hide">On this page</h1>
    </nav>
    <div class="get-help">
      <h1>Get help</h1>
      <ul>
        <li><a href="https://www.bitovi.com/community/slack" target="_blank" class="icon-slack">Chat with us</a></li>
        <li><a href="https://github.com/canjs/canjs/issues/new" target="_blank" class="icon-github">File an issue</a></li>
        <li><a href="https://forums.bitovi.com/c/canjs" target="_blank" class="icon-forums">Ask questions</a></li>
        <li><a href="https://www.bitovi.com/blog/topic/canjs" target="_blank" class="icon-blog">Read latest news</a></li>
      </ul>
    </div>
  </div>
</div>

		
			<script>
				steal = {
				  	instantiated: {
				    	"bundles/bit-docs-site/static.css!$css" : null
				  	}
			  	};
			</script>
			<script type='text/javascript' data-main="bit-docs-site/static" src="./static/steal.production.js"></script>
		
		<script async defer src="https://buttons.github.io/buttons.js"></script>

		<!-- root-level elements with attributes necessary for the app -->
		<div path-prefix="."></div>

	</body>
</html>
